#include <memory>
#include <string>
#include <vector>
#include <map>
#include <tuple>
#include <optional>
#include <algorithm>
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <flashback/mock_database.hpp>
#include <flashback/exception.hpp>
#include <flashback/server.hpp>

class test_server: public testing::Test
{
public:
    void SetUp() override
    {
        m_mock_database = std::make_shared<flashback::mock_database>();
        m_server_context = std::make_unique<grpc::ServerContext>();
        m_server = std::make_shared<flashback::server>(m_mock_database);
        m_user = std::make_shared<flashback::User>();
        m_user->set_id(1);
        m_user->set_email("user@flashback.eu.com");
        m_user->set_name("Flashback Test User");
        m_user->set_password(R"(strong password)");
        m_user->set_device(R"(aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee)");
        m_user->set_hash(R"($argon2id$v=19$m=262144,t=3,p=1$uxpOdV39XaKTf+IjPWX8ZQ$QVfEV1ZyXWMUyUw04PbEx/SjJDxbx9t+AhYAztFATlg)");
        m_user->set_token(R"(iNFzgSaY2W+q42gM9lNVbB13v0odiLy6WnHbInbuvvE)");
    }

protected:
    std::shared_ptr<flashback::server> m_server{nullptr};
    std::shared_ptr<flashback::mock_database> m_mock_database{nullptr};
    std::shared_ptr<flashback::User> m_user{nullptr};
    std::shared_ptr<grpc::ServerContext> m_server_context{nullptr};
};

TEST_F(test_server, SignUpNonExistingUser)
{
    grpc::Status status{};
    auto const signup_request{std::make_unique<flashback::SignUpRequest>()};
    auto const signup_response{std::make_unique<flashback::SignUpResponse>()};

    auto user{std::make_unique<flashback::User>()};
    user->set_name(m_user->name());
    user->set_email(m_user->email());
    user->set_password(m_user->password());
    user->set_device(m_user->device());

    EXPECT_EQ(user->id(), 0) << "User ID should be unknown to client at any point of time";
    EXPECT_FALSE(user->name().empty()) << "Name is required for registration";
    EXPECT_FALSE(user->email().empty()) << "Email is required for registration";
    EXPECT_FALSE(user->password().empty()) << "Password is required for registration";
    EXPECT_FALSE(user->device().empty()) << "Device ID should have been generated by the client";
    EXPECT_TRUE(user->hash().empty()) << "Hash should be unknown to client at any point of time";
    EXPECT_TRUE(user->token().empty()) << "Token will be generated after sign in, so it will remain empty during sign up";

    EXPECT_CALL(*m_mock_database, user_exists(user->email())).Times(1).WillOnce(testing::Return(false));
    EXPECT_CALL(*m_mock_database, create_user(user->name(), user->email(), testing::_)).Times(1).WillOnce(testing::Return(1));

    signup_request->set_allocated_user(user.release());

    EXPECT_NO_THROW(status = m_server->SignUp(m_server_context.get(), signup_request.get(), signup_response.get()));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(signup_response->success());
    EXPECT_TRUE(signup_response->has_user());
    EXPECT_EQ(signup_response->user().id(), 0) << "Client ID should be unknown to client";
    EXPECT_TRUE(signup_response->user().hash().empty()) << "Hash should never be leaked into client side";
    EXPECT_FALSE(signup_response->user().name().empty());
    EXPECT_FALSE(signup_response->user().email().empty());
    EXPECT_FALSE(signup_response->user().device().empty());
    EXPECT_TRUE(signup_response->user().token().empty()) << "Token should be generated after sign in";
    EXPECT_TRUE(signup_response->user().password().empty()) << "Password should be cleared out after sign up";
}

TEST_F(test_server, SignUpExistingUser)
{
    EXPECT_CALL(*m_mock_database, user_exists(m_user->email())).Times(1).WillOnce(testing::Return(true));
    EXPECT_CALL(*m_mock_database, create_user).Times(0);

    grpc::Status status{};
    auto const request{std::make_unique<flashback::SignUpRequest>()};
    auto const response{std::make_unique<flashback::SignUpResponse>()};

    auto user{std::make_unique<flashback::User>()};
    user->set_name(m_user->name());
    user->set_email(m_user->email());
    user->set_password(m_user->password());
    user->set_device(m_user->device());

    EXPECT_EQ(user->id(), 0) << "User ID should be unknown to client at any point of time";
    EXPECT_FALSE(user->name().empty()) << "Name is required for registration";
    EXPECT_FALSE(user->email().empty()) << "Email is required for registration";
    EXPECT_FALSE(user->password().empty()) << "Password is required for registration";
    EXPECT_FALSE(user->device().empty()) << "Device ID should have been generated by the client";
    EXPECT_TRUE(user->hash().empty()) << "Hash should be unknown to client at any point of time";
    EXPECT_TRUE(user->token().empty()) << "Token will be generated after sign in, so it will remain empty during sign up";

    request->set_allocated_user(user.release());

    EXPECT_NO_THROW(status = m_server->SignUp(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response->success()) << "Signing up a user that already exists should fail";
    EXPECT_FALSE(response->has_user());
    EXPECT_EQ(response->user().id(), 0);
    EXPECT_TRUE(response->user().name().empty());
    EXPECT_TRUE(response->user().email().empty());
    EXPECT_TRUE(response->user().device().empty());
    EXPECT_TRUE(response->user().hash().empty());
    EXPECT_TRUE(response->user().password().empty());
    EXPECT_TRUE(response->user().token().empty());
}

TEST_F(test_server, SignUpWithIncompleteCredentials)
{
    grpc::Status status{};
    auto user{std::make_unique<flashback::User>()};
    auto const request{std::make_unique<flashback::SignUpRequest>()};
    auto const response{std::make_unique<flashback::SignUpResponse>()};

    EXPECT_FALSE(response->has_user());
    EXPECT_EQ(user->id(), 0);
    EXPECT_TRUE(user->hash().empty());
    EXPECT_TRUE(user->name().empty());
    EXPECT_TRUE(user->email().empty());
    EXPECT_TRUE(user->device().empty());
    EXPECT_TRUE(user->password().empty());

    EXPECT_CALL(*m_mock_database, user_exists(m_user->email())).Times(0);
    EXPECT_CALL(*m_mock_database, create_user).Times(0);

    EXPECT_NO_THROW(status = m_server->SignUp(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response->success()) << "Signing up with an undefined user should fail";
    EXPECT_FALSE(response->has_user());

    request->set_allocated_user(user.release());
    EXPECT_NO_THROW(status = m_server->SignUp(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response->success()) << "Signing up with a user without a name should fail";
    EXPECT_FALSE(response->has_user());

    user = std::make_unique<flashback::User>();
    user->set_name(m_user->name());
    request->set_allocated_user(user.release());
    EXPECT_NO_THROW(status = m_server->SignUp(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response->success()) << "Signing up with a user without email should fail";
    EXPECT_FALSE(response->has_user());

    user = std::make_unique<flashback::User>();
    user->set_name(m_user->name());
    user->set_email(m_user->email());
    request->set_allocated_user(user.release());
    EXPECT_NO_THROW(status = m_server->SignUp(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response->success()) << "Signing up with a user without device should fail";
    EXPECT_FALSE(response->has_user());

    user = std::make_unique<flashback::User>();
    user->set_name(m_user->name());
    user->set_email(m_user->email());
    user->set_device(m_user->device());
    request->set_allocated_user(user.release());
    EXPECT_NO_THROW(status = m_server->SignUp(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response->success()) << "Signing up with a user without password should fail";
    EXPECT_FALSE(response->has_user());
}

TEST_F(test_server, SignIn)
{
    auto request{std::make_unique<flashback::SignInRequest>()};
    auto response{std::make_unique<flashback::SignInResponse>()};
    auto user_before_signin{std::make_unique<flashback::User>()};
    auto user_after_signin{std::make_unique<flashback::User>()};

    user_before_signin->set_name(m_user->name());
    user_before_signin->set_email(m_user->email());
    user_before_signin->set_password(m_user->password());
    user_before_signin->set_device(m_user->device());

    user_after_signin->set_id(m_user->id());
    user_after_signin->set_name(m_user->name());
    user_after_signin->set_email(m_user->email());
    user_after_signin->set_device(m_user->device());
    user_after_signin->set_token(m_user->token());
    user_after_signin->clear_password();
    user_after_signin->set_hash(m_user->hash());

    EXPECT_EQ(user_before_signin->id(), 0);
    EXPECT_FALSE(user_before_signin->name().empty());
    EXPECT_FALSE(user_before_signin->email().empty());
    EXPECT_FALSE(user_before_signin->password().empty());
    EXPECT_FALSE(user_before_signin->device().empty());
    EXPECT_TRUE(user_before_signin->token().empty()) << "Token should be generated after signing in";
    EXPECT_TRUE(user_before_signin->hash().empty()) << "Hash must be cleared after sign in";

    EXPECT_EQ(user_after_signin->id(), m_user->id()) << "Client ID will be used internally by sign in but will not be returned";
    EXPECT_FALSE(user_after_signin->name().empty()) << "Name is untouched after sign in";
    EXPECT_FALSE(user_after_signin->email().empty()) << "Email is untouched after sign in";
    EXPECT_FALSE(user_after_signin->device().empty()) << "Device ID should be generated by the client before signing in";
    EXPECT_FALSE(user_after_signin->token().empty()) << "Token should be generated after signing in";
    EXPECT_TRUE(user_after_signin->password().empty()) << "Password is not stored in database, so it will be returned empty by database";
    EXPECT_FALSE(user_after_signin->hash().empty()) << "Hash will be used internally by sign up function but will not return";

    EXPECT_CALL(*m_mock_database, user_exists(m_user->email())).Times(1).WillOnce(testing::Return(true));
    EXPECT_CALL(*m_mock_database, get_user(m_user->email())).Times(1).WillOnce(testing::Return(std::move(user_after_signin)));
    EXPECT_CALL(*m_mock_database, create_session(m_user->id(), testing::A<std::string_view>(), m_user->device())).Times(1).WillOnce(testing::Return(true));

    request->set_allocated_user(user_before_signin.release());
    EXPECT_NO_THROW(m_server->SignIn(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(response->success());
    EXPECT_TRUE(response->has_user());
    EXPECT_EQ(response->user().id(), 0) << "Client ID should be unknown to client";
    EXPECT_FALSE(response->user().name().empty());
    EXPECT_FALSE(response->user().email().empty());
    EXPECT_FALSE(response->user().device().empty());
    EXPECT_FALSE(response->user().token().empty()) << "Token should have been generated after signing in";
    EXPECT_TRUE(response->user().password().empty()) << "Password should have been cleared after signing in";
    EXPECT_TRUE(response->user().hash().empty()) << "Hash should never be leaked to client side";
}

TEST_F(test_server, SignInWithInvalidCredentials)
{
    auto request{std::make_unique<flashback::SignInRequest>()};
    auto response{std::make_unique<flashback::SignInResponse>()};
    auto user_before_signin{std::make_unique<flashback::User>()};
    auto const user_after_signin{std::make_unique<flashback::User>()};

    user_before_signin->set_name(m_user->name());
    user_before_signin->set_email(m_user->email());
    user_before_signin->set_password(m_user->password().substr(0, m_user->password().size() / 2));
    user_before_signin->set_device(m_user->device());

    user_after_signin->set_id(m_user->id());
    user_after_signin->set_name(m_user->name());
    user_after_signin->set_email(m_user->email());
    user_after_signin->set_device(m_user->device());
    user_after_signin->set_token(m_user->token());
    user_after_signin->clear_password();
    user_after_signin->set_hash(m_user->hash());

    EXPECT_EQ(user_before_signin->id(), 0);
    EXPECT_FALSE(user_before_signin->name().empty());
    EXPECT_FALSE(user_before_signin->email().empty());
    EXPECT_FALSE(user_before_signin->password().empty());
    EXPECT_FALSE(user_before_signin->device().empty());
    EXPECT_TRUE(user_before_signin->token().empty()) << "Token should be generated after signing in";
    EXPECT_TRUE(user_before_signin->hash().empty()) << "Hash must be cleared after sign in";

    EXPECT_EQ(user_after_signin->id(), m_user->id()) << "Client ID will be used internally by sign in but will not be returned";
    EXPECT_FALSE(user_after_signin->name().empty()) << "Name is untouched after sign in";
    EXPECT_FALSE(user_after_signin->email().empty()) << "Email is untouched after sign in";
    EXPECT_FALSE(user_after_signin->device().empty()) << "Device ID should be generated by the client before signing in";
    EXPECT_FALSE(user_after_signin->token().empty()) << "Token should be generated after signing in";
    EXPECT_TRUE(user_after_signin->password().empty()) << "Password is not stored in database, so it will be returned empty from database";
    EXPECT_FALSE(user_after_signin->hash().empty()) << "Hash will be used internally by sign up function but will not return";

    EXPECT_CALL(*m_mock_database, user_exists(m_user->email())).Times(1).WillOnce(testing::Return(true));
    EXPECT_CALL(*m_mock_database, get_user(m_user->email())).Times(1).WillOnce(testing::Return(std::make_unique<flashback::User>(*user_after_signin)));
    EXPECT_CALL(*m_mock_database, create_session(m_user->id(), testing::A<std::string_view>(), m_user->device())).Times(0);

    request->set_allocated_user(user_before_signin.release());
    EXPECT_NO_THROW(m_server->SignIn(m_server_context.get(), request.get(), response.get()));
    EXPECT_FALSE(response->success());
    EXPECT_FALSE(response->has_user());
}

TEST_F(test_server, SignInWithIncompleteCredentials)
{
    EXPECT_CALL(*m_mock_database, user_exists(m_user->email())).Times(0);
    EXPECT_CALL(*m_mock_database, get_user(m_user->email())).Times(0);
    EXPECT_CALL(*m_mock_database, create_session(m_user->id(), testing::A<std::string_view>(), m_user->device())).Times(0);

    auto const request{std::make_unique<flashback::SignInRequest>()};
    auto const response{std::make_unique<flashback::SignInResponse>()};

    std::unique_ptr<flashback::User> user{nullptr};
    EXPECT_EQ(user, nullptr);
    EXPECT_NO_THROW(m_server->SignIn(m_server_context.get(), request.get(), response.get()));
    EXPECT_FALSE(response->success());
    EXPECT_FALSE(response->has_user());

    user = std::make_unique<flashback::User>();
    EXPECT_EQ(user->id(), 0);
    EXPECT_TRUE(user->name().empty());
    EXPECT_TRUE(user->email().empty());
    EXPECT_TRUE(user->password().empty());
    EXPECT_TRUE(user->device().empty());
    EXPECT_TRUE(user->token().empty());
    EXPECT_TRUE(user->hash().empty());
    request->set_allocated_user(user.release());
    EXPECT_NO_THROW(m_server->SignIn(m_server_context.get(), request.get(), response.get()));
    EXPECT_FALSE(response->success());
    EXPECT_FALSE(response->has_user());

    user = std::make_unique<flashback::User>();
    user->set_name(m_user->name());
    EXPECT_EQ(user->id(), 0);
    EXPECT_FALSE(user->name().empty());
    EXPECT_TRUE(user->email().empty());
    EXPECT_TRUE(user->password().empty());
    EXPECT_TRUE(user->device().empty());
    EXPECT_TRUE(user->token().empty());
    EXPECT_TRUE(user->hash().empty());
    request->set_allocated_user(user.release());
    EXPECT_NO_THROW(m_server->SignIn(m_server_context.get(), request.get(), response.get()));
    EXPECT_FALSE(response->success());
    EXPECT_FALSE(response->has_user());

    user = std::make_unique<flashback::User>();
    user->set_name(m_user->name());
    user->set_email(m_user->email());
    EXPECT_EQ(user->id(), 0);
    EXPECT_FALSE(user->name().empty());
    EXPECT_FALSE(user->email().empty());
    EXPECT_TRUE(user->password().empty());
    EXPECT_TRUE(user->device().empty());
    EXPECT_TRUE(user->token().empty());
    EXPECT_TRUE(user->hash().empty());
    request->set_allocated_user(user.release());
    EXPECT_NO_THROW(m_server->SignIn(m_server_context.get(), request.get(), response.get()));
    EXPECT_FALSE(response->success());
    EXPECT_FALSE(response->has_user());

    user = std::make_unique<flashback::User>();
    user->set_name(m_user->name());
    user->set_email(m_user->email());
    user->set_password(m_user->password());
    EXPECT_EQ(user->id(), 0);
    EXPECT_FALSE(user->name().empty());
    EXPECT_FALSE(user->email().empty());
    EXPECT_FALSE(user->password().empty());
    EXPECT_TRUE(user->device().empty());
    EXPECT_TRUE(user->token().empty());
    EXPECT_TRUE(user->hash().empty());
    request->set_allocated_user(user.release());
    EXPECT_NO_THROW(m_server->SignIn(m_server_context.get(), request.get(), response.get()));
    EXPECT_FALSE(response->success());
    EXPECT_FALSE(response->has_user());
}

TEST_F(test_server, CreateRoadmap)
{
    std::string roadmap_name{"Bug Driven Developer"};
    std::string name_with_quotes{"O'Reilly Book Reader"};
    grpc::Status status{};
    auto request{std::make_unique<flashback::CreateRoadmapRequest>()};
    auto response{std::make_unique<flashback::CreateRoadmapResponse>()};
    flashback::Roadmap expected_roadmap{};
    expected_roadmap.set_id(1);
    expected_roadmap.set_name(roadmap_name);
    flashback::Roadmap quoted_roadmap{};
    quoted_roadmap.set_id(2);
    quoted_roadmap.set_name(name_with_quotes);

    EXPECT_CALL(*m_mock_database, create_roadmap(m_user->id(), roadmap_name)).Times(1).WillOnce(testing::Return(expected_roadmap));
    EXPECT_CALL(*m_mock_database, create_roadmap(m_user->id(), name_with_quotes)).Times(1).WillOnce(testing::Return(quoted_roadmap));
    EXPECT_CALL(*m_mock_database, get_user(m_user->token(), m_user->device())).Times(4).WillOnce(testing::Return(nullptr)).WillOnce(
        testing::Return(std::make_unique<flashback::User>(*m_user))).WillOnce(testing::Return(nullptr)).WillOnce(
        testing::Return(std::make_unique<flashback::User>(*m_user)));

    request->set_name(roadmap_name);
    EXPECT_NO_THROW(status = m_server->CreateRoadmap(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response->has_roadmap()) << "User is not set, so the request should be declined";
    EXPECT_EQ(response->roadmap().id(), 0);
    EXPECT_TRUE(response->roadmap().name().empty());

    request->set_allocated_user(std::make_unique<flashback::User>(*m_user).release());
    EXPECT_NO_THROW(status = m_server->CreateRoadmap(m_server_context.get(), request.get(), response.get()));
    EXPECT_FALSE(response->has_roadmap()) << "User is set but session is invalid, therefore the request should be declined";
    EXPECT_EQ(response->roadmap().id(), 0);
    EXPECT_TRUE(response->roadmap().name().empty());

    request->set_allocated_user(std::make_unique<flashback::User>(*m_user).release());
    EXPECT_NO_THROW(status = m_server->CreateRoadmap(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(response->has_roadmap()) << "User is set and session is valid, therefore the request should be responded";
    EXPECT_GT(response->roadmap().id(), 0);
    EXPECT_EQ(response->roadmap().name(), roadmap_name);

    request->clear_name();
    EXPECT_NO_THROW(m_server->CreateRoadmap(m_server_context.get(), request.get(), response.get()));
    EXPECT_FALSE(response->has_roadmap()) << "Creating a roadmap with empty name should fail";
    EXPECT_EQ(response->roadmap().id(), 0);

    request->set_name(name_with_quotes);
    EXPECT_NO_THROW(status = m_server->CreateRoadmap(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response->has_roadmap()) << "Roadmaps with quotes in their names should be allowed";
    EXPECT_GT(response->roadmap().id(), 0);
    EXPECT_EQ(response->roadmap().name(), name_with_quotes);
}

TEST_F(test_server, GetRoadmaps)
{
    auto const request{std::make_unique<flashback::GetRoadmapsRequest>()};
    auto const response{std::make_unique<flashback::GetRoadmapsResponse>()};
    auto requesting_user{std::make_unique<flashback::User>(*m_user)};
    auto const database_retrieved_user{std::make_unique<flashback::User>(*m_user)};
    auto const roadmap{std::make_unique<flashback::Roadmap>()};

    EXPECT_CALL(*m_mock_database, get_user(testing::A<std::string_view>(), testing::A<std::string_view>())).Times(2).WillOnce(
        testing::Return(std::make_unique<flashback::User>(*database_retrieved_user))).WillOnce(
        testing::Return(std::make_unique<flashback::User>(*database_retrieved_user)));
    EXPECT_CALL(*m_mock_database, get_roadmaps(testing::A<uint64_t>())).Times(1).WillOnce(testing::Return(std::vector<flashback::Roadmap>{}));

    EXPECT_FALSE(request->has_user());
    EXPECT_NO_THROW(m_server->GetRoadmaps(m_server_context.get(), request.get(), response.get()));

    roadmap->set_id(1);
    roadmap->set_name("Overtime Working Specialist");
    request->set_allocated_user(requesting_user.release());
    EXPECT_TRUE(request->has_user());
    EXPECT_FALSE(request->user().token().empty());
    EXPECT_FALSE(request->user().device().empty());
    EXPECT_NO_THROW(m_server->GetRoadmaps(m_server_context.get(), request.get(), response.get()));
}

TEST_F(test_server, RenameRoadmap)
{
    auto request{std::make_unique<flashback::RenameRoadmapRequest>()};
    auto response{std::make_unique<flashback::RenameRoadmapResponse>()};
    auto requesting_user{std::make_unique<flashback::User>(*m_user)};
    auto database_retrieved_user{std::make_unique<flashback::User>(*m_user)};
    auto roadmap{std::make_unique<flashback::Roadmap>()};

    EXPECT_CALL(*m_mock_database, get_user(testing::A<std::string_view>(), testing::A<std::string_view>())).Times(1).WillOnce(
        testing::Return(std::make_unique<flashback::User>(*database_retrieved_user)));
    EXPECT_CALL(*m_mock_database, rename_roadmap(testing::A<uint64_t>(), testing::A<std::string_view>())).Times(1);

    EXPECT_FALSE(request->has_roadmap());
    EXPECT_FALSE(request->has_user());
    EXPECT_NO_THROW(m_server->RenameRoadmap(m_server_context.get(), request.get(), response.get()));

    roadmap->set_id(1);
    roadmap->set_name("Overtime Working Specialist");
    request->set_allocated_roadmap(roadmap.release());
    EXPECT_TRUE(request->has_roadmap());
    EXPECT_GT(request->roadmap().id(), 0);
    EXPECT_FALSE(request->has_user());
    EXPECT_FALSE(request->roadmap().name().empty());

    EXPECT_NO_THROW(m_server->RenameRoadmap(m_server_context.get(), request.get(), response.get()));

    request->set_allocated_user(requesting_user.release());
    EXPECT_TRUE(request->has_user());
    EXPECT_FALSE(request->user().token().empty());
    EXPECT_FALSE(request->user().device().empty());
    EXPECT_NO_THROW(m_server->RenameRoadmap(m_server_context.get(), request.get(), response.get()));
}

TEST_F(test_server, RemoveRoadmap)
{
    auto request{std::make_unique<flashback::RemoveRoadmapRequest>()};
    auto response{std::make_unique<flashback::RemoveRoadmapResponse>()};
    auto requesting_user{std::make_unique<flashback::User>(*m_user)};
    auto database_retrieved_user{std::make_unique<flashback::User>(*m_user)};
    auto roadmap{std::make_unique<flashback::Roadmap>()};

    EXPECT_CALL(*m_mock_database, get_user(testing::A<std::string_view>(), testing::A<std::string_view>())).Times(1).WillOnce(
        testing::Return(std::make_unique<flashback::User>(*database_retrieved_user)));
    EXPECT_CALL(*m_mock_database, remove_roadmap(testing::A<uint64_t>())).Times(1);

    EXPECT_FALSE(request->has_roadmap());
    EXPECT_FALSE(request->has_user());
    EXPECT_NO_THROW(m_server->RemoveRoadmap(m_server_context.get(), request.get(), response.get()));

    roadmap->set_id(1);
    roadmap->set_name("Overtime Working Specialist");
    request->set_allocated_roadmap(roadmap.release());
    EXPECT_TRUE(request->has_roadmap());
    EXPECT_GT(request->roadmap().id(), 0);
    EXPECT_FALSE(request->has_user());
    EXPECT_FALSE(request->roadmap().name().empty());

    EXPECT_NO_THROW(m_server->RemoveRoadmap(m_server_context.get(), request.get(), response.get()));

    request->set_allocated_user(requesting_user.release());
    EXPECT_TRUE(request->has_user());
    EXPECT_FALSE(request->user().token().empty());
    EXPECT_FALSE(request->user().device().empty());
    EXPECT_NO_THROW(m_server->RemoveRoadmap(m_server_context.get(), request.get(), response.get()));
}

TEST_F(test_server, SearchRoadmaps)
{
    std::unique_ptr<flashback::User> database_retrieved_user{nullptr};
    EXPECT_CALL(*m_mock_database, get_user(testing::A<std::string_view>(), testing::A<std::string_view>())).Times(0);
    EXPECT_CALL(*m_mock_database, search_roadmaps(testing::A<std::string_view>())).Times(0);

    auto search_request{std::make_unique<flashback::SearchRoadmapsRequest>()};
    auto search_response{std::make_unique<flashback::SearchRoadmapsResponse>()};
    EXPECT_FALSE(search_request->has_user());
    EXPECT_NO_THROW(m_server->SearchRoadmaps(m_server_context.get(), search_request.get(), search_response.get()));
    EXPECT_THAT(search_response->roadmap(), testing::SizeIs(0)) << "User is not set so the request will be declined";

    database_retrieved_user = std::make_unique<flashback::User>(*m_user);
    EXPECT_CALL(*m_mock_database, get_user(testing::A<std::string_view>(), testing::A<std::string_view>())).Times(1).WillOnce(
        testing::Return(std::make_unique<flashback::User>(*database_retrieved_user)));
    EXPECT_CALL(*m_mock_database, search_roadmaps(testing::A<std::string_view>())).Times(1).WillOnce(testing::Return(std::vector<flashback::Roadmap>{}));

    flashback::Roadmap roadmap{};
    roadmap.set_id(1);
    roadmap.set_name("Overtime Working Specialist");
    search_request->set_allocated_user(std::make_unique<flashback::User>(*m_user).release());
    EXPECT_TRUE(search_request->has_user());
    EXPECT_FALSE(search_request->user().token().empty());
    EXPECT_FALSE(search_request->user().device().empty());
    EXPECT_NO_THROW(m_server->SearchRoadmaps(m_server_context.get(), search_request.get(), search_response.get()));

    database_retrieved_user = std::make_unique<flashback::User>(*m_user);
    EXPECT_CALL(*m_mock_database, get_user(testing::A<std::string_view>(), testing::A<std::string_view>())).Times(1).WillOnce(
        testing::Return(std::make_unique<flashback::User>(*database_retrieved_user)));
    EXPECT_CALL(*m_mock_database, create_roadmap(testing::A<uint64_t>(), testing::A<std::string>())).Times(1).WillOnce(testing::Return(roadmap));

    grpc::Status status{};
    auto create_request{std::make_unique<flashback::CreateRoadmapRequest>()};
    auto create_response{std::make_unique<flashback::CreateRoadmapResponse>()};
    create_request->set_allocated_user(std::make_unique<flashback::User>(*m_user).release());
    EXPECT_TRUE(create_request->has_user());
    EXPECT_FALSE(create_request->user().token().empty());
    EXPECT_FALSE(create_request->user().device().empty());
    EXPECT_NO_THROW(status = m_server->CreateRoadmap(m_server_context.get(), create_request.get(), create_response.get()));
    EXPECT_TRUE(create_response->has_roadmap()) << "User is set and session is valid, therefore the request should be responded";
    EXPECT_EQ(create_response->roadmap().id(), roadmap.id());

    database_retrieved_user = std::make_unique<flashback::User>(*m_user);
    EXPECT_CALL(*m_mock_database, get_user(testing::A<std::string_view>(), testing::A<std::string_view>())).Times(1).WillOnce(
        testing::Return(std::make_unique<flashback::User>(*database_retrieved_user)));
    EXPECT_CALL(*m_mock_database, search_roadmaps(testing::A<std::string_view>())).Times(1).WillOnce(testing::Return(std::vector<flashback::Roadmap>{}));

    search_request->set_allocated_user(std::make_unique<flashback::User>(*m_user).release());
    EXPECT_TRUE(search_request->has_user());
    EXPECT_FALSE(search_request->user().token().empty());
    EXPECT_FALSE(search_request->user().device().empty());
    EXPECT_NO_THROW(m_server->SearchRoadmaps(m_server_context.get(), search_request.get(), search_response.get()));
}

TEST_F(test_server, CreateSubject)
{
    flashback::CreateSubjectRequest request;
    flashback::CreateSubjectResponse response;
    grpc::Status status;
    std::string const subject_name{"C++"};
    auto requesting_user{std::make_unique<flashback::User>(*m_user)};
    auto returning_user{std::make_unique<flashback::User>(*m_user)};
    flashback::Subject returning_subject{};

    request.set_allocated_user(requesting_user.release());
    request.set_name(subject_name);
    returning_subject.set_name(subject_name);
    returning_subject.set_id(1);

    EXPECT_CALL(*m_mock_database, get_user(testing::A<std::string_view>(), testing::A<std::string_view>())).Times(1).WillOnce(testing::Return(std::move(returning_user)));
    EXPECT_CALL(*m_mock_database, create_subject(testing::A<std::string>())).Times(1).WillOnce(testing::Return(returning_subject));
    EXPECT_NO_THROW(status = m_server->CreateSubject(m_server_context.get(), &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response.success());
    EXPECT_EQ(response.code(), 0);
}

TEST_F(test_server, SearchSubjects)
{
    flashback::SearchSubjectsRequest request;
    flashback::SearchSubjectsResponse response;
    grpc::ServerContext context;
    grpc::Status status;
    auto requesting_user{std::make_unique<flashback::User>(*m_user)};
    auto returning_user{std::make_unique<flashback::User>(*m_user)};
    std::string const searching_pattern{"Linux"};
    std::vector<std::string> const subject_names{"Linux Kernel", "Linux System Administration", "Linux Network Administration"};
    std::map<uint64_t, flashback::Subject> database_subjects;

    for (uint64_t index{}; auto const& name: subject_names)
    {
        ++index;
        flashback::Subject subject;
        subject.set_id(index);
        subject.set_name(name);
        database_subjects.insert({index, subject});
    }

    request.set_allocated_user(requesting_user.release());
    request.set_token(searching_pattern);

    EXPECT_CALL(*m_mock_database, get_user(testing::A<std::string_view>(), testing::A<std::string_view>())).Times(1).WillOnce(testing::Return(std::move(returning_user)));
    EXPECT_CALL(*m_mock_database, search_subjects(testing::A<std::string>())).Times(1).WillOnce(testing::Return(database_subjects));
    EXPECT_NO_THROW(status = m_server->SearchSubjects(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    ASSERT_EQ(response.subjects().size(), database_subjects.size());

    for (auto const& match: response.subjects())
    {
        uint64_t const position{match.position()};
        flashback::Subject const& subject{match.subject()};
        auto const& iter = std::ranges::find_if(database_subjects, [&match](std::pair<uint64_t, flashback::Subject> const& e) {
            return match.position() == e.first && match.subject().id() == e.second.id() && match.subject().name() == e.second.name();
        });
        EXPECT_NE(iter, database_subjects.cend());
    }

    request.clear_user();
    request.clear_token();
    response.clear_subjects();
    EXPECT_NO_THROW(status = m_server->SearchSubjects(&context, &request, &response)) << "Searching subject with no name should result in empty set with no exceptions";
    EXPECT_TRUE(status.ok());
    ASSERT_EQ(response.subjects().size(), 0) << "Searching subject with no name should result empty set";
}

TEST_F(test_server, RenameSubject)
{
    auto requesting_user{std::make_unique<flashback::User>(*m_user)};
    auto returning_user{std::make_unique<flashback::User>(*m_user)};
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::RenameSubjectRequest request{};
    flashback::RenameSubjectResponse response{};
    std::string const subject_name{"Docker"};

    EXPECT_CALL(*m_mock_database, get_user(testing::A<std::string_view>(), testing::A<std::string_view>())).Times(1).WillOnce(testing::Return(std::move(returning_user)));
    EXPECT_CALL(*m_mock_database, rename_subject(testing::A<uint64_t>(), testing::A<std::string>())).Times(1);

    EXPECT_NO_THROW(status = m_server->RenameSubject(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Renaming to an empty string should not succeed";
    EXPECT_GT(response.code(), 0) << "Renaming to an empty string should result in error code greater than zero";

    request.set_allocated_user(requesting_user.release());
    request.set_id(1);
    request.set_name(subject_name);

    EXPECT_NO_THROW(status = m_server->RenameSubject(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response.success());
    EXPECT_EQ(response.code(), 0);
}

TEST_F(test_server, AddMilestone)
{
    using testing::A;
    using testing::An;
    using testing::Return;

    auto requesting_user{std::make_unique<flashback::User>(*m_user)};
    auto returning_user{std::make_unique<flashback::User>(*m_user)};
    auto returning_user2{std::make_unique<flashback::User>(*m_user)};
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::AddMilestoneRequest request{};
    flashback::AddMilestoneResponse response{};
    flashback::Milestone milestone;
    flashback::Roadmap roadmap{};
    roadmap.set_id(1);
    milestone.set_id(1);
    milestone.set_name("NeoMutt");
    milestone.set_level(flashback::expertise_level::surface);
    milestone.set_position(1);

    request.set_subject_id(milestone.id());
    request.set_roadmap_id(roadmap.id());
    request.set_subject_level(milestone.level());
    request.clear_position();
    request.set_allocated_user(requesting_user.release());

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(2).WillOnce(Return(std::move(returning_user))).WillOnce(
        Return(std::move(returning_user2)));
    EXPECT_CALL(*m_mock_database, add_milestone(A<uint64_t>(), An<flashback::expertise_level>(), A<uint64_t>())).WillOnce(Return(milestone));
    EXPECT_CALL(*m_mock_database, add_milestone(A<uint64_t>(), An<flashback::expertise_level>(), A<uint64_t>(), A<uint64_t>())).WillOnce(Return(milestone));

    EXPECT_NO_THROW(status = m_server->AddMilestone(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response.success()) << "Milestone without position should be added";
    EXPECT_EQ(response.milestone().id(), milestone.id());
    EXPECT_EQ(response.milestone().level(), milestone.level());
    EXPECT_EQ(response.milestone().position(), milestone.position());

    request.set_position(milestone.position());

    EXPECT_NO_THROW(status = m_server->AddMilestone(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response.success()) << "Milestone with position should be added";
    EXPECT_EQ(response.milestone().id(), milestone.id());
    EXPECT_EQ(response.milestone().level(), milestone.level());
    EXPECT_EQ(response.milestone().position(), milestone.position());
}

TEST_F(test_server, GetMilestones)
{
    using testing::A;
    using testing::An;
    using testing::Return;

    auto requesting_user{std::make_unique<flashback::User>(*m_user)};
    auto database_provided_user{std::make_unique<flashback::User>(*m_user)};
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::GetMilestonesRequest request{};
    flashback::GetMilestonesResponse response{};
    flashback::Roadmap requesting_roadmap{};
    std::vector<flashback::Milestone> database_provided_milestones;

    requesting_roadmap.set_id(1);
    requesting_roadmap.set_name("eBFP");

    for (auto const& m: std::vector<std::tuple<uint64_t, uint64_t, flashback::expertise_level, std::string>>{
             {1, 10, flashback::expertise_level::surface, "eBPF"},
             {2, 20, flashback::expertise_level::depth, "C++"},
             {3, 30, flashback::expertise_level::surface, "Rust"}})
    {
        flashback::Milestone milestone{};
        milestone.set_id(std::get<0>(m));
        milestone.set_position(std::get<1>(m));
        milestone.set_level(std::get<2>(m));
        milestone.set_name(std::get<3>(m));
        database_provided_milestones.push_back(milestone);
    }

    request.set_allocated_user(requesting_user.release());
    request.set_roadmap_id(requesting_roadmap.id());

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(1).WillOnce(Return(std::move(database_provided_user)));
    EXPECT_CALL(*m_mock_database, get_milestones(A<uint64_t>())).Times(1).WillOnce(Return(database_provided_milestones));
    EXPECT_NO_THROW(status = m_server->GetMilestones(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response.success());
    EXPECT_TRUE(response.details().empty());
    EXPECT_EQ(response.code(), 0);
    EXPECT_EQ(response.milestones().size(), database_provided_milestones.size());

    for (auto const& milestone: response.milestones())
    {
        auto const& iter = std::ranges::find_if(database_provided_milestones, [&milestone](flashback::Milestone const& m) {
            return m.id() == milestone.id() && m.position() == milestone.position() && m.level() == milestone.level() && m.name() == milestone.name();
        });
        EXPECT_NE(iter, database_provided_milestones.cend());
    }
}

TEST_F(test_server, AddRequirement)
{
    using testing::A;
    using testing::An;
    using testing::Return;

    auto requesting_user{std::make_unique<flashback::User>(*m_user)};
    auto database_provided_user{std::make_unique<flashback::User>(*m_user)};
    auto roadmap{std::make_unique<flashback::Roadmap>()};
    auto milestone{std::make_unique<flashback::Milestone>()};
    auto required_milestone{std::make_unique<flashback::Milestone>()};
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::AddRequirementRequest request{};
    flashback::AddRequirementResponse response{};
    std::vector<flashback::Milestone> milestones;

    roadmap->set_id(1);
    roadmap->set_name("Embedded Linux Software Engineering");
    milestone->set_id(1);
    milestone->set_name("Linux Kernel");
    milestone->set_position(2);
    milestone->set_level(flashback::expertise_level::surface);
    required_milestone->set_id(2);
    required_milestone->set_name("C");
    required_milestone->set_position(1);
    required_milestone->set_level(flashback::expertise_level::origin);
    request.set_allocated_user(requesting_user.release());
    request.set_allocated_roadmap(roadmap.release());
    request.set_allocated_milestone(milestone.release());
    request.set_allocated_required_milestone(required_milestone.release());

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(1).WillOnce(Return(std::move(database_provided_user)));
    EXPECT_CALL(*m_mock_database, add_requirement(A<uint64_t>(), A<flashback::Milestone>(), A<flashback::Milestone>())).Times(1);
    EXPECT_NO_THROW(status = m_server->AddRequirement(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response.success());
    EXPECT_TRUE(response.details().empty());
    EXPECT_EQ(response.code(), 0);
}

TEST_F(test_server, GetRequirements)
{
    using testing::A;
    using testing::An;
    using testing::Return;

    auto requesting_user{std::make_unique<flashback::User>(*m_user)};
    auto milestone{std::make_unique<flashback::Milestone>()};
    std::vector<std::string> subject_names{"eBPF", "C++", "C", "GDB"};
    std::vector<flashback::Milestone> required_milestones{};
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::GetRequirementsRequest request{};
    flashback::GetRequirementsResponse response{};
    std::vector<flashback::Milestone> milestones;

    milestone->set_id(1);
    milestone->set_name("Linux Kernel");
    milestone->set_position(2);
    milestone->set_level(flashback::expertise_level::surface);

    uint64_t index{};
    for (std::string const& name: subject_names)
    {
        flashback::Milestone required_milestone{};
        required_milestone.set_id(++index);
        required_milestone.set_name(name);
        required_milestone.set_position(++index);
        required_milestone.set_level(flashback::expertise_level::surface);
        required_milestones.push_back(required_milestone);
    }

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(2).WillOnce(Return(std::move(std::make_unique<flashback::User>(*m_user))))
.WillOnce(Return(std::move(std::make_unique<flashback::User>(*m_user))));
    EXPECT_CALL(*m_mock_database, get_requirements(A<uint64_t>(), A<uint64_t>(), An<flashback::expertise_level>())).Times(2).WillOnce(
        Return(std::vector<flashback::Milestone>{})).WillOnce(Return(required_milestones));

    EXPECT_NO_THROW(status = m_server->GetRequirements(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Requesting requirements with invalid user should be declined";

    request.set_allocated_user(requesting_user.release());
    EXPECT_NO_THROW(status = m_server->GetRequirements(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Requesting requirements with invalid milestone should be declined";

    request.set_allocated_milestone(milestone.release());
    EXPECT_NO_THROW(status = m_server->GetRequirements(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response.success());
    EXPECT_TRUE(response.details().empty());
    EXPECT_EQ(response.code(), 0);
}

TEST_F(test_server, CloneRoadmap)
{
    using testing::A;
    using testing::An;
    using testing::Return;

    auto requesting_user{std::make_unique<flashback::User>(*m_user)};
    auto original_roadmap{std::make_unique<flashback::Roadmap>()};
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::CloneRoadmapRequest request{};
    flashback::CloneRoadmapResponse response{};
    flashback::Roadmap database_provided_roadmap{};
    std::string const roadmap_name{"Theoretical Physics"};

    original_roadmap->set_id(1);
    original_roadmap->set_name(roadmap_name);
    database_provided_roadmap.set_id(2);
    database_provided_roadmap.set_name(roadmap_name);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(2).WillOnce(Return(std::make_unique<flashback::User>(*m_user))).WillOnce(
        Return(std::make_unique<flashback::User>(*m_user)));
    EXPECT_CALL(*m_mock_database, clone_roadmap(A<uint64_t>(), A<uint64_t>())).Times(1).WillOnce(Return(database_provided_roadmap));

    EXPECT_NO_THROW(status = m_server->CloneRoadmap(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Requesting to clone a roadmap from invalid user should be declined";
    EXPECT_EQ(response.code(), 3) << "Invalid user error code should be a constant number";

    request.set_allocated_user(requesting_user.release());
    EXPECT_NO_THROW(status = m_server->CloneRoadmap(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Requesting to clone an invalid roadmap from a user should be declined";
    EXPECT_EQ(response.code(), 4);

    request.set_allocated_roadmap(original_roadmap.release());
    EXPECT_NO_THROW(status = m_server->CloneRoadmap(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response.has_roadmap());
    EXPECT_EQ(response.roadmap().id(), database_provided_roadmap.id());
    EXPECT_EQ(response.roadmap().name(), database_provided_roadmap.name());
}

TEST_F(test_server, ReorderMilestone)
{
    using testing::A;
    using testing::An;
    using testing::Return;

    auto requesting_user{std::make_unique<flashback::User>(*m_user)};
    auto roadmap{std::make_unique<flashback::Roadmap>()};
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::ReorderMilestoneRequest request{};
    flashback::ReorderMilestoneResponse response{};
    flashback::Roadmap const database_provided_roadmap{};
    roadmap->set_id(1);
    roadmap->set_name("Theoretical Physics");

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(4).WillOnce(Return(std::make_unique<flashback::User>(*m_user))).
WillOnce(Return(std::make_unique<flashback::User>(*m_user))).WillOnce(Return(std::make_unique<flashback::User>(*m_user))).WillOnce(
                                                                                             Return(std::make_unique<flashback::User>(*m_user)));
    EXPECT_CALL(*m_mock_database, reorder_milestone(A<uint64_t>(), 1, 3)).Times(1);

    EXPECT_NO_THROW(status = m_server->ReorderMilestone(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Requesting to reorder a milestone from invalid user should be declined";
    EXPECT_EQ(response.code(), 3) << "Error code for invalid user should be a constant number";

    request.set_allocated_user(requesting_user.release());
    EXPECT_NO_THROW(status = m_server->ReorderMilestone(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Requesting to reorder an invalid roadmap from a legitimate user should be declined";
    EXPECT_EQ(response.code(), 4);

    request.set_allocated_roadmap(roadmap.release());
    request.set_current_position(0);
    request.set_target_position(0);
    EXPECT_NO_THROW(status = m_server->ReorderMilestone(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Requesting to reorder a milestone with incorrect position should be declined";
    EXPECT_EQ(response.code(), 5);

    request.set_current_position(1);
    request.set_target_position(1);
    EXPECT_NO_THROW(status = m_server->ReorderMilestone(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Requesting to reorder a milestone from a position to the same position should be declined";
    EXPECT_EQ(response.code(), 6);

    request.set_current_position(1);
    request.set_target_position(3);
    EXPECT_NO_THROW(status = m_server->ReorderMilestone(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response.success()) << "Reordering two milestones from a position to another valid position should work";
    EXPECT_TRUE(response.details().empty());
    EXPECT_EQ(response.code(), 0);
}

TEST_F(test_server, RemoveMilestone)
{
    using testing::A;
    using testing::An;
    using testing::Return;

    auto user{std::make_unique<flashback::User>(*m_user)};
    auto roadmap{std::make_unique<flashback::Roadmap>()};
    auto milestone{std::make_unique<flashback::Milestone>()};
    grpc::ServerContext context{};
    grpc::Status status{};
    flashback::RemoveMilestoneRequest request{};
    flashback::RemoveMilestoneResponse response{};

    roadmap->set_id(1);
    roadmap->set_name("Theoretical Physicist");
    milestone->set_id(1);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(3).WillOnce(Return(std::make_unique<flashback::User>(*m_user))).
WillOnce(Return(std::make_unique<flashback::User>(*m_user))).WillOnce(Return(std::make_unique<flashback::User>(*m_user)));
    EXPECT_CALL(*m_mock_database, remove_milestone(A<uint64_t>(), A<uint64_t>())).Times(1);

    EXPECT_NO_THROW(status = m_server->RemoveMilestone(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Request to remove a milestone from an invalid user should be declined";
    EXPECT_EQ(response.code(), 3) << "The error for invalid user should have a constant value";
    EXPECT_FALSE(response.details().empty());

    request.set_allocated_user(user.release());
    EXPECT_NO_THROW(status = m_server->RemoveMilestone(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Request to remove a milestone with invalid roadmap should be declined";
    EXPECT_EQ(response.code(), 4);
    EXPECT_FALSE(response.details().empty());

    request.set_allocated_roadmap(roadmap.release());
    EXPECT_NO_THROW(status = m_server->RemoveMilestone(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Request to remove a milestone with invalid milestone should be declined";
    EXPECT_EQ(response.code(), 5);
    EXPECT_FALSE(response.details().empty());

    request.set_allocated_milestone(milestone.release());
    EXPECT_NO_THROW(status = m_server->RemoveMilestone(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response.success()) << "Request to remove a milestone with valid user credentials, valid roadmap and valid milestone should work";
    EXPECT_EQ(response.code(), 0);
    EXPECT_TRUE(response.details().empty());
}

TEST_F(test_server, ChangeMilestoneLevel)
{
    using testing::A;
    using testing::An;
    using testing::Return;

    auto user{std::make_unique<flashback::User>(*m_user)};
    auto roadmap{std::make_unique<flashback::Roadmap>()};
    auto milestone{std::make_unique<flashback::Milestone>()};
    grpc::ServerContext context{};
    grpc::Status status{};
    flashback::ChangeMilestoneLevelRequest request{};
    flashback::ChangeMilestoneLevelResponse response{};

    roadmap->set_id(1);
    roadmap->set_name("Theoretical Physicist");
    milestone->set_id(1);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(3).WillOnce(Return(std::make_unique<flashback::User>(*m_user))).
WillOnce(Return(std::make_unique<flashback::User>(*m_user))).WillOnce(Return(std::make_unique<flashback::User>(*m_user)));
    EXPECT_CALL(*m_mock_database, change_milestone_level(A<uint64_t>(), A<uint64_t>(), An<flashback::expertise_level>())).Times(1);

    EXPECT_NO_THROW(status = m_server->ChangeMilestoneLevel(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Request to change milestone level from an invalid user should be declined";
    EXPECT_FALSE(response.details().empty());
    EXPECT_EQ(response.code(), 3);

    request.set_allocated_user(user.release());
    EXPECT_NO_THROW(status = m_server->ChangeMilestoneLevel(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Request to change milestone level with invalid roadmap should be declined";
    EXPECT_FALSE(response.details().empty());
    EXPECT_EQ(response.code(), 4);

    request.set_allocated_roadmap(roadmap.release());
    EXPECT_NO_THROW(status = m_server->ChangeMilestoneLevel(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Request to change milestone level with invalid milestone should be declined";
    EXPECT_FALSE(response.details().empty());
    EXPECT_EQ(response.code(), 5);

    request.set_allocated_milestone(milestone.release());
    EXPECT_NO_THROW(status = m_server->ChangeMilestoneLevel(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response.success()) << "Request to change milestone with valid credentials, valid roadmap, and valid milestone should work";
    EXPECT_TRUE(response.details().empty());
    EXPECT_EQ(response.code(), 0);
}

TEST_F(test_server, RemoveSubject)
{
    using testing::A;
    using testing::An;
    using testing::Return;

    auto user{std::make_unique<flashback::User>(*m_user)};
    auto subject{std::make_unique<flashback::Subject>()};
    grpc::ServerContext context{};
    grpc::Status status{};
    flashback::RemoveSubjectRequest request{};
    flashback::RemoveSubjectResponse response{};

    subject->set_id(1);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(2).WillOnce(Return(std::make_unique<flashback::User>(*m_user))).WillOnce(
        Return(std::make_unique<flashback::User>(*m_user)));
    EXPECT_CALL(*m_mock_database, remove_subject(A<uint64_t>())).Times(1);

    EXPECT_NO_THROW(status = m_server->RemoveSubject(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Request to remove a subject with an invalid user should be declined";
    EXPECT_FALSE(response.details().empty());
    EXPECT_EQ(response.code(), 3);

    request.set_allocated_user(user.release());
    EXPECT_NO_THROW(status = m_server->RemoveSubject(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Request to remove an invalid subject should be declined";
    EXPECT_FALSE(response.details().empty());
    EXPECT_EQ(response.code(), 4);

    request.set_allocated_subject(subject.release());
    EXPECT_NO_THROW(status = m_server->RemoveSubject(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response.success()) << "Request to remove a subject with valid credentials and valid subject should work";
    EXPECT_TRUE(response.details().empty());
    EXPECT_EQ(response.code(), 0);
}

TEST_F(test_server, MergeSubjects)
{
    using testing::A;
    using testing::An;
    using testing::Return;

    auto user{std::make_unique<flashback::User>(*m_user)};
    auto source_subject{std::make_unique<flashback::Subject>()};
    auto target_subject{std::make_unique<flashback::Subject>()};
    grpc::ServerContext context{};
    grpc::Status status{};
    flashback::MergeSubjectsRequest request;
    flashback::MergeSubjectsResponse response;

    source_subject->set_id(1);
    source_subject->set_name("Linear Algebra");
    target_subject->set_id(2);
    target_subject->set_name("Graph Theory");

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(3).WillOnce(Return(std::make_unique<flashback::User>(*m_user))).WillOnce(Return(std::make_unique<flashback::User>(*m_user))).WillOnce(Return(std::make_unique<flashback::User>(*m_user)));
    EXPECT_CALL(*m_mock_database, merge_subjects(A<uint64_t>(), A<uint64_t>())).Times(1);

    EXPECT_NO_THROW(status = m_server->MergeSubjects(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Request to merge two subjects from an invalid user should be declined";
    EXPECT_FALSE(response.details().empty());
    EXPECT_EQ(response.code(), 3) << "Invalid user should be indicated by an error";

    request.set_allocated_user(user.release());
    EXPECT_NO_THROW(status = m_server->MergeSubjects(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Request to merge two invalid subjects should be declined";
    EXPECT_FALSE(response.details().empty());
    EXPECT_EQ(response.code(), 4);

    request.set_allocated_source_subject(source_subject.release());
    EXPECT_NO_THROW(status = m_server->MergeSubjects(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Request to merge two invalid subjects should be declined";
    EXPECT_FALSE(response.details().empty());
    EXPECT_EQ(response.code(), 4);

    request.set_allocated_target_subject(target_subject.release());
    EXPECT_NO_THROW(status = m_server->MergeSubjects(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response.success()) << "Request to merge two valid subjects should work";
    EXPECT_TRUE(response.details().empty());
    EXPECT_EQ(response.code(), 0);
}
