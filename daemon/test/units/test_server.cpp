#include <memory>
#include <string>
#include <vector>
#include <map>
#include <tuple>
#include <optional>
#include <algorithm>
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <flashback/mock_database.hpp>
#include <flashback/server.hpp>

using testing::A;
using testing::An;
using testing::Return;
using testing::Eq;
using testing::Ne;
using testing::IsEmpty;
using testing::SizeIs;
using testing::IsTrue;
using testing::IsFalse;
using testing::ContainerEq;
using testing::Invoke;

class test_server: public testing::Test
{
public:
    void SetUp() override
    {
        m_mock_database = std::make_shared<flashback::mock_database>();
        m_server_context = std::make_unique<grpc::ServerContext>();
        m_server = std::make_shared<flashback::server>(m_mock_database);
        m_user = std::make_shared<flashback::User>();
        m_user->set_id(1);
        m_user->set_email("user@flashback.eu.com");
        m_user->set_name("Flashback Test User");
        m_user->set_password(R"(strong password)");
        m_user->set_device(R"(aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee)");
        m_user->set_hash(R"($argon2id$v=19$m=262144,t=3,p=1$uxpOdV39XaKTf+IjPWX8ZQ$QVfEV1ZyXWMUyUw04PbEx/SjJDxbx9t+AhYAztFATlg)");
        m_user->set_token(R"(iNFzgSaY2W+q42gM9lNVbB13v0odiLy6WnHbInbuvvE)");
    }

protected:
    std::shared_ptr<flashback::server> m_server{nullptr};
    std::shared_ptr<flashback::mock_database> m_mock_database{nullptr};
    std::shared_ptr<flashback::User> m_user{nullptr};
    std::shared_ptr<grpc::ServerContext> m_server_context{nullptr};
};

TEST_F(test_server, SignUpNonExistingUser)
{
    grpc::Status status{};
    auto const signup_request{std::make_unique<flashback::SignUpRequest>()};
    auto const signup_response{std::make_unique<flashback::SignUpResponse>()};

    auto user{std::make_unique<flashback::User>()};
    user->set_name(m_user->name());
    user->set_email(m_user->email());
    user->set_password(m_user->password());
    user->set_device(m_user->device());

    EXPECT_EQ(user->id(), 0) << "User ID should be unknown to client at any point of time";
    EXPECT_FALSE(user->name().empty()) << "Name is required for registration";
    EXPECT_FALSE(user->email().empty()) << "Email is required for registration";
    EXPECT_FALSE(user->password().empty()) << "Password is required for registration";
    EXPECT_FALSE(user->device().empty()) << "Device ID should have been generated by the client";
    EXPECT_TRUE(user->hash().empty()) << "Hash should be unknown to client at any point of time";
    EXPECT_TRUE(user->token().empty()) << "Token will be generated after sign in, so it will remain empty during sign up";

    EXPECT_CALL(*m_mock_database, user_exists(user->email())).Times(1).WillOnce(testing::Return(false));
    EXPECT_CALL(*m_mock_database, create_user(user->name(), user->email(), testing::_)).Times(1).WillOnce(testing::Return(1));

    signup_request->set_allocated_user(user.release());

    EXPECT_NO_THROW(status = m_server->SignUp(m_server_context.get(), signup_request.get(), signup_response.get()));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(signup_response->success());
    EXPECT_TRUE(signup_response->has_user());
    EXPECT_EQ(signup_response->user().id(), 0) << "Client ID should be unknown to client";
    EXPECT_TRUE(signup_response->user().hash().empty()) << "Hash should never be leaked into client side";
    EXPECT_FALSE(signup_response->user().name().empty());
    EXPECT_FALSE(signup_response->user().email().empty());
    EXPECT_FALSE(signup_response->user().device().empty());
    EXPECT_TRUE(signup_response->user().token().empty()) << "Token should be generated after sign in";
    EXPECT_TRUE(signup_response->user().password().empty()) << "Password should be cleared out after sign up";
}

TEST_F(test_server, SignUpExistingUser)
{
    EXPECT_CALL(*m_mock_database, user_exists(m_user->email())).Times(1).WillOnce(testing::Return(true));
    EXPECT_CALL(*m_mock_database, create_user).Times(0);

    grpc::Status status{};
    auto const request{std::make_unique<flashback::SignUpRequest>()};
    auto const response{std::make_unique<flashback::SignUpResponse>()};

    auto user{std::make_unique<flashback::User>()};
    user->set_name(m_user->name());
    user->set_email(m_user->email());
    user->set_password(m_user->password());
    user->set_device(m_user->device());

    EXPECT_EQ(user->id(), 0) << "User ID should be unknown to client at any point of time";
    EXPECT_FALSE(user->name().empty()) << "Name is required for registration";
    EXPECT_FALSE(user->email().empty()) << "Email is required for registration";
    EXPECT_FALSE(user->password().empty()) << "Password is required for registration";
    EXPECT_FALSE(user->device().empty()) << "Device ID should have been generated by the client";
    EXPECT_TRUE(user->hash().empty()) << "Hash should be unknown to client at any point of time";
    EXPECT_TRUE(user->token().empty()) << "Token will be generated after sign in, so it will remain empty during sign up";

    request->set_allocated_user(user.release());

    EXPECT_NO_THROW(status = m_server->SignUp(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response->success()) << "Signing up a user that already exists should fail";
    EXPECT_FALSE(response->has_user());
    EXPECT_EQ(response->user().id(), 0);
    EXPECT_TRUE(response->user().name().empty());
    EXPECT_TRUE(response->user().email().empty());
    EXPECT_TRUE(response->user().device().empty());
    EXPECT_TRUE(response->user().hash().empty());
    EXPECT_TRUE(response->user().password().empty());
    EXPECT_TRUE(response->user().token().empty());
}

TEST_F(test_server, SignUpWithIncompleteCredentials)
{
    grpc::Status status{};
    auto user{std::make_unique<flashback::User>()};
    auto const request{std::make_unique<flashback::SignUpRequest>()};
    auto const response{std::make_unique<flashback::SignUpResponse>()};

    EXPECT_FALSE(response->has_user());
    EXPECT_EQ(user->id(), 0);
    EXPECT_TRUE(user->hash().empty());
    EXPECT_TRUE(user->name().empty());
    EXPECT_TRUE(user->email().empty());
    EXPECT_TRUE(user->device().empty());
    EXPECT_TRUE(user->password().empty());

    EXPECT_CALL(*m_mock_database, user_exists(m_user->email())).Times(0);
    EXPECT_CALL(*m_mock_database, create_user).Times(0);

    EXPECT_NO_THROW(status = m_server->SignUp(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response->success()) << "Signing up with an undefined user should fail";
    EXPECT_FALSE(response->has_user());

    request->set_allocated_user(user.release());
    EXPECT_NO_THROW(status = m_server->SignUp(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response->success()) << "Signing up with a user without a name should fail";
    EXPECT_FALSE(response->has_user());

    user = std::make_unique<flashback::User>();
    user->set_name(m_user->name());
    request->set_allocated_user(user.release());
    EXPECT_NO_THROW(status = m_server->SignUp(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response->success()) << "Signing up with a user without email should fail";
    EXPECT_FALSE(response->has_user());

    user = std::make_unique<flashback::User>();
    user->set_name(m_user->name());
    user->set_email(m_user->email());
    request->set_allocated_user(user.release());
    EXPECT_NO_THROW(status = m_server->SignUp(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response->success()) << "Signing up with a user without device should fail";
    EXPECT_FALSE(response->has_user());

    user = std::make_unique<flashback::User>();
    user->set_name(m_user->name());
    user->set_email(m_user->email());
    user->set_device(m_user->device());
    request->set_allocated_user(user.release());
    EXPECT_NO_THROW(status = m_server->SignUp(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response->success()) << "Signing up with a user without password should fail";
    EXPECT_FALSE(response->has_user());
}

TEST_F(test_server, SignIn)
{
    auto request{std::make_unique<flashback::SignInRequest>()};
    auto response{std::make_unique<flashback::SignInResponse>()};
    auto user_before_signin{std::make_unique<flashback::User>()};
    auto user_after_signin{std::make_unique<flashback::User>()};

    user_before_signin->set_name(m_user->name());
    user_before_signin->set_email(m_user->email());
    user_before_signin->set_password(m_user->password());
    user_before_signin->set_device(m_user->device());

    user_after_signin->set_id(m_user->id());
    user_after_signin->set_name(m_user->name());
    user_after_signin->set_email(m_user->email());
    user_after_signin->set_device(m_user->device());
    user_after_signin->set_token(m_user->token());
    user_after_signin->clear_password();
    user_after_signin->set_hash(m_user->hash());

    EXPECT_EQ(user_before_signin->id(), 0);
    EXPECT_FALSE(user_before_signin->name().empty());
    EXPECT_FALSE(user_before_signin->email().empty());
    EXPECT_FALSE(user_before_signin->password().empty());
    EXPECT_FALSE(user_before_signin->device().empty());
    EXPECT_TRUE(user_before_signin->token().empty()) << "Token should be generated after signing in";
    EXPECT_TRUE(user_before_signin->hash().empty()) << "Hash must be cleared after sign in";

    EXPECT_EQ(user_after_signin->id(), m_user->id()) << "Client ID will be used internally by sign in but will not be returned";
    EXPECT_FALSE(user_after_signin->name().empty()) << "Name is untouched after sign in";
    EXPECT_FALSE(user_after_signin->email().empty()) << "Email is untouched after sign in";
    EXPECT_FALSE(user_after_signin->device().empty()) << "Device ID should be generated by the client before signing in";
    EXPECT_FALSE(user_after_signin->token().empty()) << "Token should be generated after signing in";
    EXPECT_TRUE(user_after_signin->password().empty()) << "Password is not stored in database, so it will be returned empty by database";
    EXPECT_FALSE(user_after_signin->hash().empty()) << "Hash will be used internally by sign up function but will not return";

    EXPECT_CALL(*m_mock_database, user_exists(m_user->email())).Times(1).WillOnce(testing::Return(true));
    EXPECT_CALL(*m_mock_database, get_user(m_user->email())).Times(1).WillOnce(testing::Return(std::move(user_after_signin)));
    EXPECT_CALL(*m_mock_database, create_session(m_user->id(), testing::A<std::string_view>(), m_user->device())).Times(1).WillOnce(testing::Return(true));

    request->set_allocated_user(user_before_signin.release());
    EXPECT_NO_THROW(m_server->SignIn(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(response->success());
    EXPECT_TRUE(response->has_user());
    EXPECT_EQ(response->user().id(), 0) << "Client ID should be unknown to client";
    EXPECT_FALSE(response->user().name().empty());
    EXPECT_FALSE(response->user().email().empty());
    EXPECT_FALSE(response->user().device().empty());
    EXPECT_FALSE(response->user().token().empty()) << "Token should have been generated after signing in";
    EXPECT_TRUE(response->user().password().empty()) << "Password should have been cleared after signing in";
    EXPECT_TRUE(response->user().hash().empty()) << "Hash should never be leaked to client side";
}

TEST_F(test_server, SignOut)
{
    grpc::Status status{};
    auto request{std::make_unique<flashback::SignOutRequest>()};
    auto response{std::make_unique<flashback::SignOutResponse>()};
    auto user{std::make_unique<flashback::User>()};
    user->set_token(m_user->token());
    user->set_device(m_user->device());
    request->set_allocated_user(user.release());

    EXPECT_CALL(*m_mock_database, get_user(m_user->token(), m_user->device())).Times(2).WillRepeatedly(Invoke([this] { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, revoke_session(m_user->id(), m_user->token())).Times(1);
    EXPECT_NO_THROW(status = m_server->SignOut(m_server_context.get(), request.get(), response.get()));
    EXPECT_THAT(status.ok(), IsTrue());
}

TEST_F(test_server, SignInWithInvalidCredentials)
{
    auto request{std::make_unique<flashback::SignInRequest>()};
    auto response{std::make_unique<flashback::SignInResponse>()};
    auto user_before_signin{std::make_unique<flashback::User>()};
    auto const user_after_signin{std::make_unique<flashback::User>()};

    user_before_signin->set_name(m_user->name());
    user_before_signin->set_email(m_user->email());
    user_before_signin->set_password(m_user->password().substr(0, m_user->password().size() / 2));
    user_before_signin->set_device(m_user->device());

    user_after_signin->set_id(m_user->id());
    user_after_signin->set_name(m_user->name());
    user_after_signin->set_email(m_user->email());
    user_after_signin->set_device(m_user->device());
    user_after_signin->set_token(m_user->token());
    user_after_signin->clear_password();
    user_after_signin->set_hash(m_user->hash());

    EXPECT_EQ(user_before_signin->id(), 0);
    EXPECT_FALSE(user_before_signin->name().empty());
    EXPECT_FALSE(user_before_signin->email().empty());
    EXPECT_FALSE(user_before_signin->password().empty());
    EXPECT_FALSE(user_before_signin->device().empty());
    EXPECT_TRUE(user_before_signin->token().empty()) << "Token should be generated after signing in";
    EXPECT_TRUE(user_before_signin->hash().empty()) << "Hash must be cleared after sign in";

    EXPECT_EQ(user_after_signin->id(), m_user->id()) << "Client ID will be used internally by sign in but will not be returned";
    EXPECT_FALSE(user_after_signin->name().empty()) << "Name is untouched after sign in";
    EXPECT_FALSE(user_after_signin->email().empty()) << "Email is untouched after sign in";
    EXPECT_FALSE(user_after_signin->device().empty()) << "Device ID should be generated by the client before signing in";
    EXPECT_FALSE(user_after_signin->token().empty()) << "Token should be generated after signing in";
    EXPECT_TRUE(user_after_signin->password().empty()) << "Password is not stored in database, so it will be returned empty from database";
    EXPECT_FALSE(user_after_signin->hash().empty()) << "Hash will be used internally by sign up function but will not return";

    EXPECT_CALL(*m_mock_database, user_exists(m_user->email())).Times(1).WillOnce(testing::Return(true));
    EXPECT_CALL(*m_mock_database, get_user(m_user->email())).Times(1).WillOnce(testing::Return(std::make_unique<flashback::User>(*user_after_signin)));
    EXPECT_CALL(*m_mock_database, create_session(m_user->id(), testing::A<std::string_view>(), m_user->device())).Times(0);

    request->set_allocated_user(user_before_signin.release());
    EXPECT_NO_THROW(m_server->SignIn(m_server_context.get(), request.get(), response.get()));
    EXPECT_FALSE(response->success());
    EXPECT_FALSE(response->has_user());
}

TEST_F(test_server, SignInWithIncompleteCredentials)
{
    EXPECT_CALL(*m_mock_database, user_exists(m_user->email())).Times(0);
    EXPECT_CALL(*m_mock_database, get_user(m_user->email())).Times(0);
    EXPECT_CALL(*m_mock_database, create_session(m_user->id(), testing::A<std::string_view>(), m_user->device())).Times(0);

    auto const request{std::make_unique<flashback::SignInRequest>()};
    auto const response{std::make_unique<flashback::SignInResponse>()};

    std::unique_ptr<flashback::User> user{nullptr};
    EXPECT_EQ(user, nullptr);
    EXPECT_NO_THROW(m_server->SignIn(m_server_context.get(), request.get(), response.get()));
    EXPECT_FALSE(response->success());
    EXPECT_FALSE(response->has_user());

    user = std::make_unique<flashback::User>();
    EXPECT_EQ(user->id(), 0);
    EXPECT_TRUE(user->name().empty());
    EXPECT_TRUE(user->email().empty());
    EXPECT_TRUE(user->password().empty());
    EXPECT_TRUE(user->device().empty());
    EXPECT_TRUE(user->token().empty());
    EXPECT_TRUE(user->hash().empty());
    request->set_allocated_user(user.release());
    EXPECT_NO_THROW(m_server->SignIn(m_server_context.get(), request.get(), response.get()));
    EXPECT_FALSE(response->success());
    EXPECT_FALSE(response->has_user());

    user = std::make_unique<flashback::User>();
    user->set_name(m_user->name());
    EXPECT_EQ(user->id(), 0);
    EXPECT_FALSE(user->name().empty());
    EXPECT_TRUE(user->email().empty());
    EXPECT_TRUE(user->password().empty());
    EXPECT_TRUE(user->device().empty());
    EXPECT_TRUE(user->token().empty());
    EXPECT_TRUE(user->hash().empty());
    request->set_allocated_user(user.release());
    EXPECT_NO_THROW(m_server->SignIn(m_server_context.get(), request.get(), response.get()));
    EXPECT_FALSE(response->success());
    EXPECT_FALSE(response->has_user());

    user = std::make_unique<flashback::User>();
    user->set_name(m_user->name());
    user->set_email(m_user->email());
    EXPECT_EQ(user->id(), 0);
    EXPECT_FALSE(user->name().empty());
    EXPECT_FALSE(user->email().empty());
    EXPECT_TRUE(user->password().empty());
    EXPECT_TRUE(user->device().empty());
    EXPECT_TRUE(user->token().empty());
    EXPECT_TRUE(user->hash().empty());
    request->set_allocated_user(user.release());
    EXPECT_NO_THROW(m_server->SignIn(m_server_context.get(), request.get(), response.get()));
    EXPECT_FALSE(response->success());
    EXPECT_FALSE(response->has_user());

    user = std::make_unique<flashback::User>();
    user->set_name(m_user->name());
    user->set_email(m_user->email());
    user->set_password(m_user->password());
    EXPECT_EQ(user->id(), 0);
    EXPECT_FALSE(user->name().empty());
    EXPECT_FALSE(user->email().empty());
    EXPECT_FALSE(user->password().empty());
    EXPECT_TRUE(user->device().empty());
    EXPECT_TRUE(user->token().empty());
    EXPECT_TRUE(user->hash().empty());
    request->set_allocated_user(user.release());
    EXPECT_NO_THROW(m_server->SignIn(m_server_context.get(), request.get(), response.get()));
    EXPECT_FALSE(response->success());
    EXPECT_FALSE(response->has_user());
}

TEST_F(test_server, CreateRoadmapWithInvalidUser)
{
    std::string roadmap_name{"Bug Driven Developer"};
    std::string name_with_quotes{"O'Reilly Book Reader"};
    grpc::Status status{};
    auto request{std::make_unique<flashback::CreateRoadmapRequest>()};
    auto response{std::make_unique<flashback::CreateRoadmapResponse>()};
    flashback::Roadmap expected_roadmap{};
    expected_roadmap.set_id(1);
    expected_roadmap.set_name(roadmap_name);
    flashback::Roadmap quoted_roadmap{};
    quoted_roadmap.set_id(2);
    quoted_roadmap.set_name(name_with_quotes);

    request->set_name(roadmap_name);
    EXPECT_CALL(*m_mock_database, create_roadmap(m_user->id(), roadmap_name)).Times(0);
    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(0);
    EXPECT_NO_THROW(status = m_server->CreateRoadmap(m_server_context.get(), request.get(), response.get()));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_code(), grpc::StatusCode::UNAUTHENTICATED);
    EXPECT_THAT(response->has_roadmap(), IsFalse()) << "User is not set, so the request should be declined";
    EXPECT_THAT(response->roadmap().id(), Eq(0));
    EXPECT_THAT(response->roadmap().name(), IsEmpty());
}

TEST_F(test_server, CreateRoadmapWithUnauthenticatedUser)
{
    std::string roadmap_name{"Bug Driven Developer"};
    grpc::Status status{};
    auto valid_no_session_user{std::make_unique<flashback::User>()};
    auto response{std::make_unique<flashback::CreateRoadmapResponse>()};
    auto request{std::make_unique<flashback::CreateRoadmapRequest>()};
    request->set_allocated_user(valid_no_session_user.release());
    request->set_name(roadmap_name);
    EXPECT_CALL(*m_mock_database, create_roadmap(A<uint64_t>(), roadmap_name)).Times(0);
    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(1).WillOnce(Return(nullptr));
    EXPECT_NO_THROW(status = m_server->CreateRoadmap(m_server_context.get(), request.get(), response.get()));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));
    EXPECT_THAT(response->has_roadmap(), IsFalse()) << "User is set but session is invalid, therefore the request should be declined";
    EXPECT_THAT(response->roadmap().id(), Eq(0));
    EXPECT_THAT(response->roadmap().name(), IsEmpty());
}

TEST_F(test_server, CreateRoadmapWithAuthenticatedUser)
{
    std::string roadmap_name{"Bug Driven Developer"};
    std::string name_with_quotes{"O'Reilly Book Reader"};
    grpc::Status status{};
    auto request{std::make_unique<flashback::CreateRoadmapRequest>()};
    auto response{std::make_unique<flashback::CreateRoadmapResponse>()};
    flashback::Roadmap expected_roadmap{};
    expected_roadmap.set_id(1);
    expected_roadmap.set_name(roadmap_name);
    flashback::Roadmap quoted_roadmap{};
    quoted_roadmap.set_id(2);
    quoted_roadmap.set_name(name_with_quotes);

    request->set_name(roadmap_name);
    request->set_allocated_user(std::make_unique<flashback::User>(*m_user).release());
    EXPECT_CALL(*m_mock_database, create_roadmap(m_user->id(), roadmap_name)).Times(1).WillOnce(Return(expected_roadmap));
    EXPECT_CALL(*m_mock_database, get_user(m_user->token(), m_user->device())).Times(2).WillRepeatedly(Invoke([this] { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_NO_THROW(status = m_server->CreateRoadmap(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(response->has_roadmap()) << "User is set and session is valid, therefore the request should be responded";
    EXPECT_GT(response->roadmap().id(), 0);
    EXPECT_EQ(response->roadmap().name(), roadmap_name);
}

TEST_F(test_server, CreateRoadmapWithEmptyName)
{
    std::string roadmap_name{"Bug Driven Developer"};
    std::string name_with_quotes{"O'Reilly Book Reader"};
    grpc::Status status{};
    auto request{std::make_unique<flashback::CreateRoadmapRequest>()};
    auto response{std::make_unique<flashback::CreateRoadmapResponse>()};
    flashback::Roadmap expected_roadmap{};
    expected_roadmap.set_id(1);
    expected_roadmap.set_name(roadmap_name);
    flashback::Roadmap quoted_roadmap{};
    quoted_roadmap.set_id(2);
    quoted_roadmap.set_name(name_with_quotes);

    request->set_name(roadmap_name);
    request->set_allocated_user(std::make_unique<flashback::User>(*m_user).release());
    request->clear_name();
    flashback::Roadmap const empty_roadmap{};
    EXPECT_CALL(*m_mock_database, create_roadmap(m_user->id(), roadmap_name)).Times(0);
    EXPECT_CALL(*m_mock_database, get_user(m_user->token(), m_user->device())).Times(1).WillOnce(Invoke([this] { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_NO_THROW(m_server->CreateRoadmap(m_server_context.get(), request.get(), response.get()));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(response->has_roadmap(), IsFalse()) << "Creating a roadmap with empty name should fail";
    EXPECT_THAT(response->roadmap().id(), Eq(0));
}

TEST_F(test_server, CreateRoadmapWithQuotedName)
{
    std::string roadmap_name{"Bug Driven Developer"};
    std::string name_with_quotes{"O'Reilly Book Reader"};
    grpc::Status status{};
    auto request{std::make_unique<flashback::CreateRoadmapRequest>()};
    auto response{std::make_unique<flashback::CreateRoadmapResponse>()};
    flashback::Roadmap expected_roadmap{};
    expected_roadmap.set_id(1);
    expected_roadmap.set_name(roadmap_name);
    flashback::Roadmap quoted_roadmap{};
    quoted_roadmap.set_id(2);
    quoted_roadmap.set_name(name_with_quotes);

    request->set_allocated_user(std::make_unique<flashback::User>(*m_user).release());
    request->set_name(name_with_quotes);
    EXPECT_CALL(*m_mock_database, create_roadmap(m_user->id(), name_with_quotes)).Times(1).WillOnce(Return(quoted_roadmap));
    EXPECT_CALL(*m_mock_database, get_user(m_user->token(), m_user->device())).Times(2).WillRepeatedly(Invoke([this] { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_NO_THROW(status = m_server->CreateRoadmap(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response->has_roadmap()) << "Roadmaps with quotes in their names should be allowed";
    EXPECT_GT(response->roadmap().id(), 0);
    EXPECT_EQ(response->roadmap().name(), name_with_quotes);
}

TEST_F(test_server, GetRoadmaps)
{
    auto const request{std::make_unique<flashback::GetRoadmapsRequest>()};
    auto const response{std::make_unique<flashback::GetRoadmapsResponse>()};
    auto requesting_user{std::make_unique<flashback::User>(*m_user)};
    auto const database_retrieved_user{std::make_unique<flashback::User>(*m_user)};
    auto const roadmap{std::make_unique<flashback::Roadmap>()};

    EXPECT_CALL(*m_mock_database, get_user(testing::A<std::string_view>(), testing::A<std::string_view>())).Times(2).WillOnce(
        testing::Return(std::make_unique<flashback::User>(*database_retrieved_user))).WillOnce(testing::Return(std::make_unique<flashback::User>(*database_retrieved_user)));
    EXPECT_CALL(*m_mock_database, get_roadmaps(testing::A<uint64_t>())).Times(1).WillOnce(testing::Return(std::vector<flashback::Roadmap>{}));

    EXPECT_FALSE(request->has_user());
    EXPECT_NO_THROW(m_server->GetRoadmaps(m_server_context.get(), request.get(), response.get()));

    roadmap->set_id(1);
    roadmap->set_name("Overtime Working Specialist");
    request->set_allocated_user(requesting_user.release());
    EXPECT_TRUE(request->has_user());
    EXPECT_FALSE(request->user().token().empty());
    EXPECT_FALSE(request->user().device().empty());
    EXPECT_NO_THROW(m_server->GetRoadmaps(m_server_context.get(), request.get(), response.get()));
}

TEST_F(test_server, RenameRoadmap)
{
    auto request{std::make_unique<flashback::RenameRoadmapRequest>()};
    auto response{std::make_unique<flashback::RenameRoadmapResponse>()};
    auto requesting_user{std::make_unique<flashback::User>(*m_user)};
    auto database_retrieved_user{std::make_unique<flashback::User>(*m_user)};
    auto roadmap{std::make_unique<flashback::Roadmap>()};

    EXPECT_CALL(*m_mock_database, get_user(testing::A<std::string_view>(), testing::A<std::string_view>())).Times(1).WillOnce(
        testing::Return(std::make_unique<flashback::User>(*database_retrieved_user)));
    EXPECT_CALL(*m_mock_database, rename_roadmap(testing::A<uint64_t>(), testing::A<std::string_view>())).Times(1);

    EXPECT_FALSE(request->has_roadmap());
    EXPECT_FALSE(request->has_user());
    EXPECT_NO_THROW(m_server->RenameRoadmap(m_server_context.get(), request.get(), response.get()));

    roadmap->set_id(1);
    roadmap->set_name("Overtime Working Specialist");
    request->set_allocated_roadmap(roadmap.release());
    EXPECT_TRUE(request->has_roadmap());
    EXPECT_GT(request->roadmap().id(), 0);
    EXPECT_FALSE(request->has_user());
    EXPECT_FALSE(request->roadmap().name().empty());

    EXPECT_NO_THROW(m_server->RenameRoadmap(m_server_context.get(), request.get(), response.get()));

    request->set_allocated_user(requesting_user.release());
    EXPECT_TRUE(request->has_user());
    EXPECT_FALSE(request->user().token().empty());
    EXPECT_FALSE(request->user().device().empty());
    EXPECT_NO_THROW(m_server->RenameRoadmap(m_server_context.get(), request.get(), response.get()));
}

TEST_F(test_server, RemoveRoadmap)
{
    auto request{std::make_unique<flashback::RemoveRoadmapRequest>()};
    auto response{std::make_unique<flashback::RemoveRoadmapResponse>()};
    auto requesting_user{std::make_unique<flashback::User>(*m_user)};
    auto database_retrieved_user{std::make_unique<flashback::User>(*m_user)};
    auto roadmap{std::make_unique<flashback::Roadmap>()};

    EXPECT_CALL(*m_mock_database, get_user(testing::A<std::string_view>(), testing::A<std::string_view>())).Times(2).WillRepeatedly(Invoke([&database_retrieved_user]
    {
        return std::make_unique<flashback::User>(*database_retrieved_user);
    }));
    EXPECT_CALL(*m_mock_database, remove_roadmap(testing::A<uint64_t>())).Times(1);

    EXPECT_FALSE(request->has_roadmap());
    EXPECT_FALSE(request->has_user());
    EXPECT_NO_THROW(m_server->RemoveRoadmap(m_server_context.get(), request.get(), response.get()));

    roadmap->set_id(1);
    roadmap->set_name("Overtime Working Specialist");
    request->set_allocated_roadmap(roadmap.release());
    EXPECT_TRUE(request->has_roadmap());
    EXPECT_GT(request->roadmap().id(), 0);
    EXPECT_FALSE(request->has_user());
    EXPECT_FALSE(request->roadmap().name().empty());
    EXPECT_NO_THROW(m_server->RemoveRoadmap(m_server_context.get(), request.get(), response.get()));

    request->set_allocated_user(requesting_user.release());
    EXPECT_TRUE(request->has_user());
    EXPECT_FALSE(request->user().token().empty());
    EXPECT_FALSE(request->user().device().empty());
    EXPECT_NO_THROW(m_server->RemoveRoadmap(m_server_context.get(), request.get(), response.get()));
}

TEST_F(test_server, SearchRoadmapsWithInvalidUser)
{
    grpc::Status status{};
    std::unique_ptr<flashback::User> database_retrieved_user{nullptr};
    auto search_request{std::make_unique<flashback::SearchRoadmapsRequest>()};
    auto search_response{std::make_unique<flashback::SearchRoadmapsResponse>()};
    EXPECT_CALL(*m_mock_database, get_user(testing::A<std::string_view>(), testing::A<std::string_view>())).Times(0);
    EXPECT_CALL(*m_mock_database, search_roadmaps(testing::A<std::string_view>())).Times(0);
    EXPECT_FALSE(search_request->has_user());
    EXPECT_NO_THROW(status = m_server->SearchRoadmaps(m_server_context.get(), search_request.get(), search_response.get()));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));
    EXPECT_THAT(search_response->roadmap(), testing::SizeIs(0)) << "User is not set so the request will be declined";
}

TEST_F(test_server, SearchRoadmapsWithUnauthenticatedUser)
{
    grpc::Status status{};
    std::unique_ptr<flashback::User> database_retrieved_user{nullptr};
    auto search_request{std::make_unique<flashback::SearchRoadmapsRequest>()};
    auto search_response{std::make_unique<flashback::SearchRoadmapsResponse>()};
    flashback::Roadmap roadmap{};
    roadmap.set_id(1);
    roadmap.set_name("Overtime Working Specialist");
    auto search_result_user{std::make_unique<flashback::User>(*m_user)};
    search_result_user->clear_token();
    search_result_user->clear_device();
    search_request->set_allocated_user(search_result_user.release());
    search_request->clear_token();
    database_retrieved_user = std::make_unique<flashback::User>(*m_user);
    database_retrieved_user->clear_token();
    database_retrieved_user->clear_device();
    EXPECT_CALL(*m_mock_database, get_user(testing::A<std::string_view>(), testing::A<std::string_view>())).Times(1).WillOnce(Return(nullptr));
    EXPECT_CALL(*m_mock_database, search_roadmaps(testing::A<std::string_view>())).Times(0);
    EXPECT_THAT(search_request->has_user(), IsTrue());
    EXPECT_THAT(search_request->user().token(), IsEmpty());
    EXPECT_THAT(search_request->user().device(), IsEmpty());
    EXPECT_NO_THROW(status = m_server->SearchRoadmaps(m_server_context.get(), search_request.get(), search_response.get()));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));
}

TEST_F(test_server, SearchRoadmapsWithAuthenticatedUser)
{
    grpc::Status status{};
    std::unique_ptr<flashback::User> database_retrieved_user{nullptr};
    auto search_request{std::make_unique<flashback::SearchRoadmapsRequest>()};
    auto search_response{std::make_unique<flashback::SearchRoadmapsResponse>()};
    flashback::Roadmap roadmap{};
    roadmap.set_id(1);
    roadmap.set_name("Overtime Working Specialist");
    database_retrieved_user = std::make_unique<flashback::User>(*m_user);
    search_request->set_allocated_user(std::make_unique<flashback::User>(*m_user).release());
    search_request->set_token("work");
    EXPECT_CALL(*m_mock_database, get_user(m_user->token(), m_user->device())).Times(1).WillRepeatedly(Invoke([&database_retrieved_user] { return std::make_unique<flashback::User>(*database_retrieved_user); }));
    EXPECT_CALL(*m_mock_database, search_roadmaps(testing::A<std::string_view>())).Times(1).WillOnce(Return(std::map<uint64_t, flashback::Roadmap>{}));
    EXPECT_THAT(search_request->has_user(), IsTrue());
    EXPECT_THAT(search_request->user().token(), Not(IsEmpty()));
    EXPECT_THAT(search_request->user().device(), Not(IsEmpty()));
    EXPECT_THAT(search_request->token(), Not(IsEmpty()));
    EXPECT_NO_THROW(status = m_server->SearchRoadmaps(m_server_context.get(), search_request.get(), search_response.get()));
    EXPECT_THAT(status.ok(), IsTrue());
}

TEST_F(test_server, SearchRoadmapsWithEmptyToken)
{
    grpc::Status status{};
    std::unique_ptr<flashback::User> database_retrieved_user{nullptr};
    auto search_request{std::make_unique<flashback::SearchRoadmapsRequest>()};
    auto search_response{std::make_unique<flashback::SearchRoadmapsResponse>()};
    flashback::Roadmap roadmap{};
    roadmap.set_id(1);
    roadmap.set_name("Overtime Working Specialist");
    database_retrieved_user = std::make_unique<flashback::User>(*m_user);
    search_request->set_allocated_user(std::make_unique<flashback::User>(*m_user).release());
    search_request->clear_token();
    EXPECT_CALL(*m_mock_database, get_user(m_user->token(), m_user->device())).Times(1).WillRepeatedly(Invoke([&database_retrieved_user] { return std::make_unique<flashback::User>(*database_retrieved_user); }));
    EXPECT_CALL(*m_mock_database, search_roadmaps(testing::A<std::string_view>())).Times(1).WillOnce(Return(std::map<uint64_t, flashback::Roadmap>{}));
    EXPECT_THAT(search_request->has_user(), IsTrue());
    EXPECT_THAT(search_request->user().token(), Not(IsEmpty()));
    EXPECT_THAT(search_request->user().device(), Not(IsEmpty()));
    EXPECT_THAT(search_request->token(), IsEmpty());
    EXPECT_NO_THROW(status = m_server->SearchRoadmaps(m_server_context.get(), search_request.get(), search_response.get()));
    EXPECT_THAT(status.ok(), IsTrue());
}

TEST_F(test_server, CreateSubject)
{
    flashback::CreateSubjectRequest request;
    flashback::CreateSubjectResponse response;
    grpc::Status status;
    std::string const subject_name{"C++"};
    auto requesting_user{std::make_unique<flashback::User>(*m_user)};
    auto returning_user{std::make_unique<flashback::User>(*m_user)};
    flashback::Subject returning_subject{};

    request.set_allocated_user(requesting_user.release());
    request.set_name(subject_name);
    returning_subject.set_name(subject_name);
    returning_subject.set_id(1);

    EXPECT_CALL(*m_mock_database, get_user(testing::A<std::string_view>(), testing::A<std::string_view>())).Times(1).WillOnce(testing::Return(std::move(returning_user)));
    EXPECT_CALL(*m_mock_database, create_subject(testing::A<std::string>())).Times(1).WillOnce(testing::Return(returning_subject));
    EXPECT_NO_THROW(status = m_server->CreateSubject(m_server_context.get(), &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response.success());
    EXPECT_EQ(response.code(), 0);
}

TEST_F(test_server, SearchSubjects)
{
    flashback::SearchSubjectsRequest request;
    flashback::SearchSubjectsResponse response;
    grpc::ServerContext context;
    grpc::Status status;
    auto requesting_user{std::make_unique<flashback::User>(*m_user)};
    auto returning_user{std::make_unique<flashback::User>(*m_user)};
    std::string const searching_pattern{"Linux"};
    std::vector<std::string> const subject_names{"Linux Kernel", "Linux System Administration", "Linux Network Administration"};
    std::map<uint64_t, flashback::Subject> database_subjects;

    for (uint64_t index{}; auto const& name: subject_names)
    {
        ++index;
        flashback::Subject subject;
        subject.set_id(index);
        subject.set_name(name);
        database_subjects.insert({index, subject});
    }

    request.set_allocated_user(requesting_user.release());
    request.set_token(searching_pattern);

    EXPECT_CALL(*m_mock_database, get_user(testing::A<std::string_view>(), testing::A<std::string_view>())).Times(1).WillOnce(testing::Return(std::move(returning_user)));
    EXPECT_CALL(*m_mock_database, search_subjects(testing::A<std::string_view>())).Times(1).WillOnce(testing::Return(database_subjects));
    EXPECT_NO_THROW(status = m_server->SearchSubjects(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    ASSERT_EQ(response.subjects().size(), database_subjects.size());

    for (auto const& match: response.subjects())
    {
        uint64_t const position{match.position()};
        flashback::Subject const& subject{match.subject()};
        auto const& iter = std::ranges::find_if(database_subjects, [&match](std::pair<uint64_t, flashback::Subject> const& e)
        {
            return match.position() == e.first && match.subject().id() == e.second.id() && match.subject().name() == e.second.name();
        });
        EXPECT_NE(iter, database_subjects.cend());
    }

    request.clear_user();
    request.clear_token();
    response.clear_subjects();
    EXPECT_NO_THROW(status = m_server->SearchSubjects(&context, &request, &response)) << "Searching subject with no name should result in empty set with no exceptions";
    EXPECT_TRUE(status.ok());
    ASSERT_EQ(response.subjects().size(), 0) << "Searching subject with no name should result empty set";
}

TEST_F(test_server, RenameSubject)
{
    auto requesting_user{std::make_unique<flashback::User>(*m_user)};
    auto returning_user{std::make_unique<flashback::User>(*m_user)};
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::RenameSubjectRequest request{};
    flashback::RenameSubjectResponse response{};
    std::string const subject_name{"Docker"};

    EXPECT_CALL(*m_mock_database, get_user(testing::A<std::string_view>(), testing::A<std::string_view>())).Times(1).WillOnce(testing::Return(std::move(returning_user)));
    EXPECT_CALL(*m_mock_database, rename_subject(testing::A<uint64_t>(), testing::A<std::string>())).Times(1);

    EXPECT_NO_THROW(status = m_server->RenameSubject(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Renaming to an empty string should not succeed";
    EXPECT_GT(response.code(), 0) << "Renaming to an empty string should result in error code greater than zero";

    request.set_allocated_user(requesting_user.release());
    request.set_id(1);
    request.set_name(subject_name);

    EXPECT_NO_THROW(status = m_server->RenameSubject(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response.success());
    EXPECT_EQ(response.code(), 0);
}

TEST_F(test_server, AddMilestone)
{
    using testing::A;
    using testing::An;
    using testing::Return;

    auto requesting_user{std::make_unique<flashback::User>(*m_user)};
    auto returning_user{std::make_unique<flashback::User>(*m_user)};
    auto returning_user2{std::make_unique<flashback::User>(*m_user)};
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::AddMilestoneRequest request{};
    flashback::AddMilestoneResponse response{};
    flashback::Milestone milestone;
    flashback::Roadmap roadmap{};
    roadmap.set_id(1);
    milestone.set_id(1);
    milestone.set_name("NeoMutt");
    milestone.set_level(flashback::expertise_level::surface);
    milestone.set_position(1);

    request.set_subject_id(milestone.id());
    request.set_roadmap_id(roadmap.id());
    request.set_subject_level(milestone.level());
    request.clear_position();
    request.set_allocated_user(requesting_user.release());

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(2).WillOnce(Return(std::move(returning_user))).WillOnce(
        Return(std::move(returning_user2)));
    EXPECT_CALL(*m_mock_database, add_milestone(A<uint64_t>(), An<flashback::expertise_level>(), A<uint64_t>())).WillOnce(Return(milestone));
    EXPECT_CALL(*m_mock_database, add_milestone(A<uint64_t>(), An<flashback::expertise_level>(), A<uint64_t>(), A<uint64_t>())).WillOnce(Return(milestone));

    EXPECT_NO_THROW(status = m_server->AddMilestone(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response.success()) << "Milestone without position should be added";
    EXPECT_EQ(response.milestone().id(), milestone.id());
    EXPECT_EQ(response.milestone().level(), milestone.level());
    EXPECT_EQ(response.milestone().position(), milestone.position());

    request.set_position(milestone.position());

    EXPECT_NO_THROW(status = m_server->AddMilestone(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response.success()) << "Milestone with position should be added";
    EXPECT_EQ(response.milestone().id(), milestone.id());
    EXPECT_EQ(response.milestone().level(), milestone.level());
    EXPECT_EQ(response.milestone().position(), milestone.position());
}

TEST_F(test_server, GetMilestones)
{
    using testing::A;
    using testing::An;
    using testing::Return;

    auto requesting_user{std::make_unique<flashback::User>(*m_user)};
    auto database_provided_user{std::make_unique<flashback::User>(*m_user)};
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::GetMilestonesRequest request{};
    flashback::GetMilestonesResponse response{};
    flashback::Roadmap requesting_roadmap{};
    std::vector<flashback::Milestone> database_provided_milestones;

    requesting_roadmap.set_id(1);
    requesting_roadmap.set_name("eBFP");

    for (auto const& m: std::vector<std::tuple<uint64_t, uint64_t, flashback::expertise_level, std::string>>{
             {1, 10, flashback::expertise_level::surface, "eBPF"},
             {2, 20, flashback::expertise_level::depth, "C++"},
             {3, 30, flashback::expertise_level::surface, "Rust"}
         })
    {
        flashback::Milestone milestone{};
        milestone.set_id(std::get<0>(m));
        milestone.set_position(std::get<1>(m));
        milestone.set_level(std::get<2>(m));
        milestone.set_name(std::get<3>(m));
        database_provided_milestones.push_back(milestone);
    }

    request.set_allocated_user(requesting_user.release());
    request.set_roadmap_id(requesting_roadmap.id());

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(1).WillOnce(Return(std::move(database_provided_user)));
    EXPECT_CALL(*m_mock_database, get_milestones(A<uint64_t>())).Times(1).WillOnce(Return(database_provided_milestones));
    EXPECT_NO_THROW(status = m_server->GetMilestones(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response.success());
    EXPECT_TRUE(response.details().empty());
    EXPECT_EQ(response.code(), 0);
    EXPECT_EQ(response.milestones().size(), database_provided_milestones.size());

    for (auto const& milestone: response.milestones())
    {
        auto const& iter = std::ranges::find_if(database_provided_milestones, [&milestone](flashback::Milestone const& m)
        {
            return m.id() == milestone.id() && m.position() == milestone.position() && m.level() == milestone.level() && m.name() == milestone.name();
        });
        EXPECT_NE(iter, database_provided_milestones.cend());
    }
}

TEST_F(test_server, AddRequirement)
{
    using testing::A;
    using testing::An;
    using testing::Return;

    auto requesting_user{std::make_unique<flashback::User>(*m_user)};
    auto database_provided_user{std::make_unique<flashback::User>(*m_user)};
    auto roadmap{std::make_unique<flashback::Roadmap>()};
    auto milestone{std::make_unique<flashback::Milestone>()};
    auto required_milestone{std::make_unique<flashback::Milestone>()};
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::AddRequirementRequest request{};
    flashback::AddRequirementResponse response{};
    std::vector<flashback::Milestone> milestones;

    roadmap->set_id(1);
    roadmap->set_name("Embedded Linux Software Engineering");
    milestone->set_id(1);
    milestone->set_name("Linux Kernel");
    milestone->set_position(2);
    milestone->set_level(flashback::expertise_level::surface);
    required_milestone->set_id(2);
    required_milestone->set_name("C");
    required_milestone->set_position(1);
    required_milestone->set_level(flashback::expertise_level::origin);
    request.set_allocated_user(requesting_user.release());
    request.set_allocated_roadmap(roadmap.release());
    request.set_allocated_milestone(milestone.release());
    request.set_allocated_required_milestone(required_milestone.release());

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(1).WillOnce(Return(std::move(database_provided_user)));
    EXPECT_CALL(*m_mock_database, add_requirement(A<uint64_t>(), A<flashback::Milestone>(), A<flashback::Milestone>())).Times(1);
    EXPECT_NO_THROW(status = m_server->AddRequirement(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response.success());
    EXPECT_TRUE(response.details().empty());
    EXPECT_EQ(response.code(), 0);
}

TEST_F(test_server, GetRequirements)
{
    using testing::A;
    using testing::An;
    using testing::Return;

    auto requesting_user{std::make_unique<flashback::User>(*m_user)};
    auto milestone{std::make_unique<flashback::Milestone>()};
    std::vector<std::string> subject_names{"eBPF", "C++", "C", "GDB"};
    std::vector<flashback::Milestone> required_milestones{};
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::GetRequirementsRequest request{};
    flashback::GetRequirementsResponse response{};
    std::vector<flashback::Milestone> milestones;

    milestone->set_id(1);
    milestone->set_name("Linux Kernel");
    milestone->set_position(2);
    milestone->set_level(flashback::expertise_level::surface);

    uint64_t index{};
    for (std::string const& name: subject_names)
    {
        flashback::Milestone required_milestone{};
        required_milestone.set_id(++index);
        required_milestone.set_name(name);
        required_milestone.set_position(++index);
        required_milestone.set_level(flashback::expertise_level::surface);
        required_milestones.push_back(required_milestone);
    }

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(2).WillOnce(Return(std::move(std::make_unique<flashback::User>(*m_user)))).WillOnce(
        Return(std::move(std::make_unique<flashback::User>(*m_user))));
    EXPECT_CALL(*m_mock_database, get_requirements(A<uint64_t>(), A<uint64_t>(), An<flashback::expertise_level>())).Times(2).WillOnce(Return(std::vector<flashback::Milestone>{})).
WillOnce(Return(required_milestones));

    EXPECT_NO_THROW(status = m_server->GetRequirements(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Requesting requirements with invalid user should be declined";

    request.set_allocated_user(requesting_user.release());
    EXPECT_NO_THROW(status = m_server->GetRequirements(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Requesting requirements with invalid milestone should be declined";

    request.set_allocated_milestone(milestone.release());
    EXPECT_NO_THROW(status = m_server->GetRequirements(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response.success());
    EXPECT_TRUE(response.details().empty());
    EXPECT_EQ(response.code(), 0);
}

TEST_F(test_server, CloneRoadmap)
{
    using testing::A;
    using testing::An;
    using testing::Return;

    auto requesting_user{std::make_unique<flashback::User>(*m_user)};
    auto original_roadmap{std::make_unique<flashback::Roadmap>()};
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::CloneRoadmapRequest request{};
    flashback::CloneRoadmapResponse response{};
    flashback::Roadmap database_provided_roadmap{};
    std::string const roadmap_name{"Theoretical Physics"};

    original_roadmap->set_id(1);
    original_roadmap->set_name(roadmap_name);
    database_provided_roadmap.set_id(2);
    database_provided_roadmap.set_name(roadmap_name);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(3).WillRepeatedly(Invoke([this] { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, clone_roadmap(A<uint64_t>(), A<uint64_t>())).Times(1).WillOnce(Return(database_provided_roadmap));

    EXPECT_NO_THROW(status = m_server->CloneRoadmap(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Requesting to clone a roadmap from invalid user should be declined";
    EXPECT_EQ(response.code(), 3) << "Invalid user error code should be a constant number";

    request.set_allocated_user(requesting_user.release());
    EXPECT_NO_THROW(status = m_server->CloneRoadmap(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Requesting to clone an invalid roadmap from a user should be declined";
    EXPECT_EQ(response.code(), 4);

    request.set_allocated_roadmap(original_roadmap.release());
    EXPECT_NO_THROW(status = m_server->CloneRoadmap(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response.has_roadmap());
    EXPECT_EQ(response.roadmap().id(), database_provided_roadmap.id());
    EXPECT_EQ(response.roadmap().name(), database_provided_roadmap.name());
}

TEST_F(test_server, ReorderMilestone)
{
    using testing::A;
    using testing::An;
    using testing::Return;

    auto requesting_user{std::make_unique<flashback::User>(*m_user)};
    auto roadmap{std::make_unique<flashback::Roadmap>()};
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::ReorderMilestoneRequest request{};
    flashback::ReorderMilestoneResponse response{};
    flashback::Roadmap const database_provided_roadmap{};
    roadmap->set_id(1);
    roadmap->set_name("Theoretical Physics");

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(4).WillOnce(Return(std::make_unique<flashback::User>(*m_user))).
WillOnce(Return(std::make_unique<flashback::User>(*m_user))).WillOnce(Return(std::make_unique<flashback::User>(*m_user))).WillOnce(
                                                                                             Return(std::make_unique<flashback::User>(*m_user)));
    EXPECT_CALL(*m_mock_database, reorder_milestone(A<uint64_t>(), 1, 3)).Times(1);

    EXPECT_NO_THROW(status = m_server->ReorderMilestone(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Requesting to reorder a milestone from invalid user should be declined";
    EXPECT_EQ(response.code(), 3) << "Error code for invalid user should be a constant number";

    request.set_allocated_user(requesting_user.release());
    EXPECT_NO_THROW(status = m_server->ReorderMilestone(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Requesting to reorder an invalid roadmap from a legitimate user should be declined";
    EXPECT_EQ(response.code(), 4);

    request.set_allocated_roadmap(roadmap.release());
    request.set_current_position(0);
    request.set_target_position(0);
    EXPECT_NO_THROW(status = m_server->ReorderMilestone(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Requesting to reorder a milestone with incorrect position should be declined";
    EXPECT_EQ(response.code(), 5);

    request.set_current_position(1);
    request.set_target_position(1);
    EXPECT_NO_THROW(status = m_server->ReorderMilestone(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Requesting to reorder a milestone from a position to the same position should be declined";
    EXPECT_EQ(response.code(), 6);

    request.set_current_position(1);
    request.set_target_position(3);
    EXPECT_NO_THROW(status = m_server->ReorderMilestone(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response.success()) << "Reordering two milestones from a position to another valid position should work";
    EXPECT_TRUE(response.details().empty());
    EXPECT_EQ(response.code(), 0);
}

TEST_F(test_server, RemoveMilestone)
{
    using testing::A;
    using testing::An;
    using testing::Return;

    auto user{std::make_unique<flashback::User>(*m_user)};
    auto roadmap{std::make_unique<flashback::Roadmap>()};
    auto milestone{std::make_unique<flashback::Milestone>()};
    grpc::ServerContext context{};
    grpc::Status status{};
    flashback::RemoveMilestoneRequest request{};
    flashback::RemoveMilestoneResponse response{};

    roadmap->set_id(1);
    roadmap->set_name("Theoretical Physicist");
    milestone->set_id(1);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(3).WillOnce(Return(std::make_unique<flashback::User>(*m_user))).
WillOnce(Return(std::make_unique<flashback::User>(*m_user))).WillOnce(Return(std::make_unique<flashback::User>(*m_user)));
    EXPECT_CALL(*m_mock_database, remove_milestone(A<uint64_t>(), A<uint64_t>())).Times(1);

    EXPECT_NO_THROW(status = m_server->RemoveMilestone(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Request to remove a milestone from an invalid user should be declined";
    EXPECT_EQ(response.code(), 3) << "The error for invalid user should have a constant value";
    EXPECT_FALSE(response.details().empty());

    request.set_allocated_user(user.release());
    EXPECT_NO_THROW(status = m_server->RemoveMilestone(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Request to remove a milestone with invalid roadmap should be declined";
    EXPECT_EQ(response.code(), 4);
    EXPECT_FALSE(response.details().empty());

    request.set_allocated_roadmap(roadmap.release());
    EXPECT_NO_THROW(status = m_server->RemoveMilestone(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Request to remove a milestone with invalid milestone should be declined";
    EXPECT_EQ(response.code(), 5);
    EXPECT_FALSE(response.details().empty());

    request.set_allocated_milestone(milestone.release());
    EXPECT_NO_THROW(status = m_server->RemoveMilestone(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response.success()) << "Request to remove a milestone with valid user credentials, valid roadmap and valid milestone should work";
    EXPECT_EQ(response.code(), 0);
    EXPECT_TRUE(response.details().empty());
}

TEST_F(test_server, ChangeMilestoneLevel)
{
    using testing::A;
    using testing::An;
    using testing::Return;

    auto user{std::make_unique<flashback::User>(*m_user)};
    auto roadmap{std::make_unique<flashback::Roadmap>()};
    auto milestone{std::make_unique<flashback::Milestone>()};
    grpc::ServerContext context{};
    grpc::Status status{};
    flashback::ChangeMilestoneLevelRequest request{};
    flashback::ChangeMilestoneLevelResponse response{};

    roadmap->set_id(1);
    roadmap->set_name("Theoretical Physicist");
    milestone->set_id(1);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(3).WillOnce(Return(std::make_unique<flashback::User>(*m_user))).
WillOnce(Return(std::make_unique<flashback::User>(*m_user))).WillOnce(Return(std::make_unique<flashback::User>(*m_user)));
    EXPECT_CALL(*m_mock_database, change_milestone_level(A<uint64_t>(), A<uint64_t>(), An<flashback::expertise_level>())).Times(1);

    EXPECT_NO_THROW(status = m_server->ChangeMilestoneLevel(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Request to change milestone level from an invalid user should be declined";
    EXPECT_FALSE(response.details().empty());
    EXPECT_EQ(response.code(), 3);

    request.set_allocated_user(user.release());
    EXPECT_NO_THROW(status = m_server->ChangeMilestoneLevel(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Request to change milestone level with invalid roadmap should be declined";
    EXPECT_FALSE(response.details().empty());
    EXPECT_EQ(response.code(), 4);

    request.set_allocated_roadmap(roadmap.release());
    EXPECT_NO_THROW(status = m_server->ChangeMilestoneLevel(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Request to change milestone level with invalid milestone should be declined";
    EXPECT_FALSE(response.details().empty());
    EXPECT_EQ(response.code(), 5);

    request.set_allocated_milestone(milestone.release());
    EXPECT_NO_THROW(status = m_server->ChangeMilestoneLevel(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response.success()) << "Request to change milestone with valid credentials, valid roadmap, and valid milestone should work";
    EXPECT_TRUE(response.details().empty());
    EXPECT_EQ(response.code(), 0);
}

TEST_F(test_server, RemoveSubject)
{
    using testing::A;
    using testing::An;
    using testing::Return;

    auto user{std::make_unique<flashback::User>(*m_user)};
    auto subject{std::make_unique<flashback::Subject>()};
    grpc::ServerContext context{};
    grpc::Status status{};
    flashback::RemoveSubjectRequest request{};
    flashback::RemoveSubjectResponse response{};

    subject->set_id(1);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(2).WillOnce(Return(std::make_unique<flashback::User>(*m_user))).WillOnce(
        Return(std::make_unique<flashback::User>(*m_user)));
    EXPECT_CALL(*m_mock_database, remove_subject(A<uint64_t>())).Times(1);

    EXPECT_NO_THROW(status = m_server->RemoveSubject(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Request to remove a subject with an invalid user should be declined";
    EXPECT_FALSE(response.details().empty());
    EXPECT_EQ(response.code(), 3);

    request.set_allocated_user(user.release());
    EXPECT_NO_THROW(status = m_server->RemoveSubject(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Request to remove an invalid subject should be declined";
    EXPECT_FALSE(response.details().empty());
    EXPECT_EQ(response.code(), 4);

    request.set_allocated_subject(subject.release());
    EXPECT_NO_THROW(status = m_server->RemoveSubject(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response.success()) << "Request to remove a subject with valid credentials and valid subject should work";
    EXPECT_TRUE(response.details().empty());
    EXPECT_EQ(response.code(), 0);
}

TEST_F(test_server, MergeSubjects)
{
    auto user{std::make_unique<flashback::User>(*m_user)};
    auto source_subject{std::make_unique<flashback::Subject>()};
    auto target_subject{std::make_unique<flashback::Subject>()};
    grpc::ServerContext context{};
    grpc::Status status{};
    flashback::MergeSubjectsRequest request;
    flashback::MergeSubjectsResponse response;

    source_subject->set_id(1);
    source_subject->set_name("Linear Algebra");
    target_subject->set_id(2);
    target_subject->set_name("Graph Theory");

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(3).WillOnce(Return(std::make_unique<flashback::User>(*m_user))).
WillOnce(Return(std::make_unique<flashback::User>(*m_user))).WillOnce(Return(std::make_unique<flashback::User>(*m_user)));
    EXPECT_CALL(*m_mock_database, merge_subjects(A<uint64_t>(), A<uint64_t>())).Times(1);

    EXPECT_NO_THROW(status = m_server->MergeSubjects(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Request to merge two subjects from an invalid user should be declined";
    EXPECT_FALSE(response.details().empty());
    EXPECT_EQ(response.code(), 3) << "Invalid user should be indicated by an error";

    request.set_allocated_user(user.release());
    EXPECT_NO_THROW(status = m_server->MergeSubjects(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Request to merge two invalid subjects should be declined";
    EXPECT_FALSE(response.details().empty());
    EXPECT_EQ(response.code(), 4);

    request.set_allocated_source_subject(source_subject.release());
    EXPECT_NO_THROW(status = m_server->MergeSubjects(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response.success()) << "Request to merge two invalid subjects should be declined";
    EXPECT_FALSE(response.details().empty());
    EXPECT_EQ(response.code(), 4);

    request.set_allocated_target_subject(target_subject.release());
    EXPECT_NO_THROW(status = m_server->MergeSubjects(&context, &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response.success()) << "Request to merge two valid subjects should work";
    EXPECT_TRUE(response.details().empty());
    EXPECT_EQ(response.code(), 0);
}

MATCHER_P(HasResourceId, expected_resource, "") { return arg.id() == expected_resource.id(); }

TEST_F(test_server, GetResources)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::GetResourcesRequest request{};
    flashback::GetResourcesResponse response{};
    std::vector<flashback::Resource> resources{};
    auto subject{std::make_unique<flashback::Subject>()};
    auto user{std::make_unique<flashback::User>(*m_user)};

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(2).WillRepeatedly(Invoke([this] { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, get_resources(A<uint64_t>(), A<uint64_t>())).Times(1).WillOnce(Return(resources));

    request.clear_user();
    request.clear_subject();
    EXPECT_NO_THROW(status = m_server->GetResources(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(response.success(), IsFalse());
    EXPECT_THAT(response.code(), Eq(3)) << "Invalid user should have a specific error code";
    EXPECT_THAT(response.details().empty(), IsFalse());
    EXPECT_THAT(response.resources(), IsEmpty());

    subject->set_id(1);
    request.set_allocated_subject(subject.release());
    subject.reset(nullptr);
    request.set_allocated_user(user.release());
    user.reset(nullptr);
    EXPECT_NO_THROW(status = m_server->GetResources(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(response.success(), IsTrue());
    EXPECT_THAT(response.code(), Eq(0));
    EXPECT_THAT(response.details().empty(), IsTrue());
    EXPECT_THAT(response.resources(), SizeIs(resources.size()));
}

TEST_F(test_server, CreateResource)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::CreateResourceRequest request{};
    flashback::CreateResourceResponse response{};
    auto resource{std::make_unique<flashback::Resource>()};
    auto user{std::make_unique<flashback::User>(*m_user)};

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(1).WillOnce(Return(std::make_unique<flashback::User>(*m_user)));
    EXPECT_CALL(*m_mock_database, create_resource(testing::_)).Times(1).WillOnce(Return(*resource));

    request.clear_user();
    request.clear_resource();
    EXPECT_NO_THROW(status = m_server->CreateResource(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(response.success(), IsFalse());
    EXPECT_THAT(response.code(), Eq(3));
    EXPECT_THAT(response.details().empty(), IsFalse());

    request.set_allocated_user(user.release());
    user.reset(nullptr);
    request.set_allocated_resource(resource.release());
    resource.reset(nullptr);
    EXPECT_NO_THROW(status = m_server->CreateResource(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(response.success(), IsTrue());
    EXPECT_THAT(response.code(), Eq(0));
    EXPECT_THAT(response.details().empty(), IsTrue());
}

TEST_F(test_server, AddResourceToSubject)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::AddResourceToSubjectRequest request{};
    flashback::AddResourceToSubjectResponse response{};
    auto resource{std::make_unique<flashback::Resource>()};
    auto subject{std::make_unique<flashback::Subject>()};
    auto user{std::make_unique<flashback::User>(*m_user)};

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(1).WillOnce(Return(std::make_unique<flashback::User>(*m_user)));
    EXPECT_CALL(*m_mock_database, add_resource_to_subject(testing::_, testing::_)).Times(1);

    request.clear_user();
    request.clear_resource();
    EXPECT_NO_THROW(status = m_server->AddResourceToSubject(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(response.success(), IsFalse());
    EXPECT_THAT(response.code(), Eq(3));
    EXPECT_THAT(response.details().empty(), IsFalse());

    subject->set_id(1);
    resource->set_id(1);
    request.set_allocated_user(user.release());
    user.reset(nullptr);
    request.set_allocated_resource(resource.release());
    resource.reset(nullptr);
    request.set_allocated_subject(subject.release());
    resource.reset(nullptr);
    EXPECT_NO_THROW(status = m_server->AddResourceToSubject(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(response.success(), IsTrue());
    EXPECT_THAT(response.code(), Eq(0));
    EXPECT_THAT(response.details().empty(), IsTrue());
}

TEST_F(test_server, DropResourceFromSubject)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::DropResourceFromSubjectRequest request{};
    flashback::DropResourceFromSubjectResponse response{};
    auto resource{std::make_unique<flashback::Resource>()};
    auto subject{std::make_unique<flashback::Subject>()};
    auto user{std::make_unique<flashback::User>(*m_user)};

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(1).WillOnce(Return(std::make_unique<flashback::User>(*m_user)));
    EXPECT_CALL(*m_mock_database, drop_resource_from_subject(testing::_, testing::_)).Times(1);

    request.clear_user();
    request.clear_resource();
    EXPECT_NO_THROW(status = m_server->DropResourceFromSubject(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(response.success(), IsFalse());
    EXPECT_THAT(response.code(), Eq(3));
    EXPECT_THAT(response.details().empty(), IsFalse());

    subject->set_id(1);
    resource->set_id(1);
    request.set_allocated_user(user.release());
    user.reset(nullptr);
    request.set_allocated_resource(resource.release());
    resource.reset(nullptr);
    request.set_allocated_subject(subject.release());
    resource.reset(nullptr);
    EXPECT_NO_THROW(status = m_server->DropResourceFromSubject(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(response.success(), IsTrue());
    EXPECT_THAT(response.code(), Eq(0));
    EXPECT_THAT(response.details().empty(), IsTrue());
}

TEST_F(test_server, SearchRsources)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::SearchResourcesRequest request{};
    flashback::SearchResourcesResponse response{};
    std::map<uint64_t, flashback::Resource> const search_results{};

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(1).WillOnce(Return(std::make_unique<flashback::User>(*m_user)));
    EXPECT_CALL(*m_mock_database, search_resources(A<std::string_view>())).Times(1).WillOnce(Return(search_results));

    request.clear_user();
    request.clear_search_token();
    EXPECT_NO_THROW(status = m_server->SearchResources(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(response.success(), IsFalse());
    EXPECT_THAT(response.code(), Eq(3));
    EXPECT_THAT(response.details().empty(), IsFalse());
    EXPECT_THAT(response.results(), IsEmpty());

    flashback::User* user{request.mutable_user()};
    *user = *m_user;
    request.set_search_token("Some Resource");
    EXPECT_NO_THROW(status = m_server->SearchResources(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(response.success(), IsTrue());
    EXPECT_THAT(response.code(), Eq(0));
    EXPECT_THAT(response.details().empty(), IsTrue());
    EXPECT_THAT(response.results(), SizeIs(search_results.size()));
}

TEST_F(test_server, MergeResources)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::MergeResourcesRequest request{};
    flashback::MergeResourcesResponse response{};
    flashback::Resource resource_source{};
    flashback::Resource resource_target{};
    resource_source.set_id(1);
    resource_target.set_id(2);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(1).WillOnce(Return(std::make_unique<flashback::User>(*m_user)));
    EXPECT_CALL(*m_mock_database, merge_resources(A<uint64_t>(), A<uint64_t>())).Times(1);

    request.clear_user();
    request.clear_source();
    request.clear_target();
    EXPECT_NO_THROW(status = m_server->MergeResources(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(response.success(), IsFalse());
    EXPECT_THAT(response.code(), Eq(3));
    EXPECT_THAT(response.details().empty(), IsFalse());

    flashback::User* user{request.mutable_user()};
    flashback::Resource* source{request.mutable_source()};
    flashback::Resource* target{request.mutable_target()};
    *user = *m_user;
    *source = resource_source;
    *target = resource_target;
    EXPECT_NO_THROW(status = m_server->MergeResources(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(response.success(), IsTrue());
    EXPECT_THAT(response.code(), Eq(0));
    EXPECT_THAT(response.details().empty(), IsTrue());
}

TEST_F(test_server, RemoveResource)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::RemoveResourceRequest request{};
    flashback::RemoveResourceResponse response{};

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).Times(1).WillOnce(Return(std::make_unique<flashback::User>(*m_user)));
    EXPECT_CALL(*m_mock_database, remove_resource(A<uint64_t>())).Times(1);

    request.clear_user();
    request.clear_resource();
    EXPECT_NO_THROW(status = m_server->RemoveResource(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(response.success(), IsFalse());
    EXPECT_THAT(response.code(), Eq(3));
    EXPECT_THAT(response.details().empty(), IsFalse());

    flashback::User* user{request.mutable_user()};
    flashback::Resource* resource{request.mutable_resource()};
    *user = *m_user;
    resource->set_id(1);
    EXPECT_NO_THROW(status = m_server->RemoveResource(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(response.success(), IsTrue());
    EXPECT_THAT(response.code(), Eq(0));
    EXPECT_THAT(response.details().empty(), IsTrue());
}

TEST_F(test_server, EditResource)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::EditResourceRequest request{};
    flashback::EditResourceResponse response{};
    flashback::Resource existing_resource{};
    existing_resource.set_id(1);
    existing_resource.set_name("C++ Book");
    existing_resource.set_link("https://flashback.eu.com");
    existing_resource.set_type(flashback::Resource::book);
    existing_resource.set_pattern(flashback::Resource::chapter);
    existing_resource.set_production(std::chrono::system_clock::now().time_since_epoch().count());
    existing_resource.set_expiration(std::chrono::system_clock::now().time_since_epoch().count() + 10000);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, get_resource(A<uint64_t>())).WillRepeatedly(Return(existing_resource));

    request.clear_user();
    request.clear_resource();
    EXPECT_NO_THROW(status = m_server->EditResource(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(response.success(), IsFalse());
    EXPECT_THAT(response.code(), Eq(3));
    EXPECT_THAT(response.details().empty(), IsFalse());

    flashback::User* user{request.mutable_user()};
    *user = *m_user;
    flashback::Resource* resource{request.mutable_resource()};
    *resource = existing_resource;

    EXPECT_NO_THROW(status = m_server->EditResource(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(response.success(), IsFalse());
    EXPECT_THAT(response.code(), Eq(5));
    EXPECT_THAT(response.details().empty(), IsFalse());

    resource->set_name("Another C++ Book");
    EXPECT_CALL(*m_mock_database, rename_resource(A<uint64_t>(), A<std::string>())).Times(1);
    EXPECT_NO_THROW(status = m_server->EditResource(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(response.success(), IsTrue());
    EXPECT_THAT(response.code(), Eq(0));
    EXPECT_THAT(response.details().empty(), IsTrue());
    resource->set_name(existing_resource.name());

    resource->set_link("https:://example.com");
    EXPECT_CALL(*m_mock_database, edit_resource_link(A<uint64_t>(), A<std::string>())).Times(1);
    EXPECT_NO_THROW(status = m_server->EditResource(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(response.success(), IsTrue());
    EXPECT_THAT(response.code(), Eq(0));
    EXPECT_THAT(response.details().empty(), IsTrue());
    resource->set_link(existing_resource.link());

    resource->set_type(flashback::Resource::channel);
    EXPECT_CALL(*m_mock_database, change_resource_type(A<uint64_t>(), A<flashback::Resource::resource_type>())).Times(1);
    EXPECT_NO_THROW(status = m_server->EditResource(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(response.success(), IsTrue());
    EXPECT_THAT(response.code(), Eq(0));
    EXPECT_THAT(response.details().empty(), IsTrue());
    resource->set_type(existing_resource.type());

    resource->set_pattern(flashback::Resource::episode);
    EXPECT_CALL(*m_mock_database, change_section_pattern(A<uint64_t>(), A<flashback::Resource::section_pattern>())).Times(1);
    EXPECT_NO_THROW(status = m_server->EditResource(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(response.success(), IsTrue());
    EXPECT_THAT(response.code(), Eq(0));
    EXPECT_THAT(response.details().empty(), IsTrue());
    resource->set_pattern(existing_resource.pattern());

    resource->set_production(std::chrono::system_clock::now().time_since_epoch().count() - 1000);
    EXPECT_CALL(*m_mock_database, edit_resource_production(A<uint64_t>(), A<uint64_t>())).Times(1);
    EXPECT_NO_THROW(status = m_server->EditResource(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(response.success(), IsTrue());
    EXPECT_THAT(response.code(), Eq(0));
    EXPECT_THAT(response.details().empty(), IsTrue());
    resource->set_production(existing_resource.production());

    resource->set_expiration(std::chrono::system_clock::now().time_since_epoch().count() - 1000);
    EXPECT_CALL(*m_mock_database, edit_resource_expiration(A<uint64_t>(), A<uint64_t>())).Times(1);
    EXPECT_NO_THROW(status = m_server->EditResource(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(response.success(), IsTrue());
    EXPECT_THAT(response.code(), Eq(0));
    EXPECT_THAT(response.details().empty(), IsTrue());
    resource->set_expiration(existing_resource.expiration());
}

TEST_F(test_server, CreateNerve)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::CreateNerveRequest request{};
    flashback::CreateNerveResponse response{};
    flashback::Subject subject{};
    flashback::Resource resource{};
    resource.set_id(1);
    resource.set_name("C++");
    resource.clear_link();
    resource.set_type(flashback::Resource::nerve);
    resource.set_pattern(flashback::Resource::synapse);
    resource.set_production(std::chrono::system_clock::now().time_since_epoch().count());
    resource.clear_expiration();
    subject.set_name("C++");

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, create_nerve(A<uint64_t>(), A<std::string>(), A<uint64_t>(), A<uint64_t>())).Times(1).WillRepeatedly(Return(resource));

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->CreateNerve(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_resource() = resource;
    *request.mutable_subject() = subject;

    EXPECT_NO_THROW(status = m_server->CreateNerve(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::OK));
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, GetNerves)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::GetNervesRequest request{};
    flashback::GetNervesResponse response{};
    std::vector<flashback::Resource> expected_nerves{};
    flashback::Resource nerve{};

    nerve.set_id(1);
    nerve.set_name("C++");
    nerve.clear_link();
    nerve.set_type(flashback::Resource::nerve);
    nerve.set_pattern(flashback::Resource::synapse);
    nerve.set_production(std::chrono::system_clock::now().time_since_epoch().count());
    nerve.clear_expiration();
    expected_nerves.push_back(nerve);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, get_nerves(A<uint64_t>())).Times(1).WillRepeatedly(Return(expected_nerves));

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->GetNerves(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    flashback::User* user{request.mutable_user()};
    *user = *m_user;

    EXPECT_NO_THROW(status = m_server->GetNerves(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, CreateProvider)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::CreateProviderRequest request{};
    flashback::CreateProviderResponse response{};
    flashback::Provider provider{};

    provider.set_name("Brian Salehi");

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, create_provider(A<std::string>())).Times(1).WillOnce(Return(provider));

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->CreateProvider(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_provider() = provider;

    EXPECT_NO_THROW(status = m_server->CreateProvider(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, AddProvider)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::AddProviderRequest request{};
    flashback::AddProviderResponse response{};
    flashback::Resource resource{};
    flashback::Provider provider{};

    provider.set_name("Brian Salehi");
    provider.set_id(1);
    resource.set_id(1);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, add_provider(A<uint64_t>(), A<uint64_t>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->AddProvider(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_provider() = provider;
    *request.mutable_resource() = resource;

    EXPECT_NO_THROW(status = m_server->AddProvider(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, DropProvider)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::DropProviderRequest request{};
    flashback::DropProviderResponse response{};
    flashback::Resource resource{};
    flashback::Provider provider{};

    provider.set_name("Brian Salehi");
    provider.set_id(1);
    resource.set_id(1);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, drop_provider(A<uint64_t>(), A<uint64_t>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->DropProvider(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_provider() = provider;
    *request.mutable_resource() = resource;

    EXPECT_NO_THROW(status = m_server->DropProvider(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, SearchProviders)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::SearchProvidersRequest request{};
    flashback::SearchProvidersResponse response{};
    std::map<uint64_t, flashback::Provider> providers{};
    flashback::Provider provider{};

    provider.set_name("Brian Salehi");
    provider.set_id(1);
    providers.insert({provider.id(), provider});

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, search_providers(A<std::string_view>())).Times(1).WillOnce(Return(providers));

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->SearchProviders(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    request.set_search_token("Brian Salehi");

    EXPECT_NO_THROW(status = m_server->SearchProviders(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, RenameProvider)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::RenameProviderRequest request{};
    flashback::RenameProviderResponse response{};
    flashback::Provider provider{};

    provider.set_name("Brian Salehi");
    provider.set_id(1);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, rename_provider(A<uint64_t>(), A<std::string>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->RenameProvider(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_provider() = provider;

    EXPECT_NO_THROW(status = m_server->RenameProvider(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, RemoveProvider)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::RemoveProviderRequest request{};
    flashback::RemoveProviderResponse response{};
    flashback::Provider provider{};

    provider.set_name("Brian Salehi");
    provider.set_id(1);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, remove_provider(A<uint64_t>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->RemoveProvider(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_provider() = provider;

    EXPECT_NO_THROW(status = m_server->RemoveProvider(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, MergeProviders)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::MergeProvidersRequest request{};
    flashback::MergeProvidersResponse response{};
    flashback::Provider provider{};

    provider.set_name("Brian Salehi");
    provider.set_id(1);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, merge_providers(A<uint64_t>(), A<uint64_t>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->MergeProviders(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_source() = provider;
    *request.mutable_target() = provider;

    EXPECT_NO_THROW(status = m_server->MergeProviders(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, CreatePresenter)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::CreatePresenterRequest request{};
    flashback::CreatePresenterResponse response{};
    flashback::Presenter presenter{};

    presenter.set_name("Brian Salehi");
    presenter.clear_id();

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, create_presenter(A<std::string>())).Times(1).WillOnce(Return(presenter));

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->CreatePresenter(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_presenter() = presenter;

    EXPECT_NO_THROW(status = m_server->CreatePresenter(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, AddPresenter)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::AddPresenterRequest request{};
    flashback::AddPresenterResponse response{};
    flashback::Presenter presenter{};
    flashback::Resource resource{};

    presenter.set_name("Brian Salehi");
    presenter.set_id(1);
    resource.set_id(1);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, add_presenter(A<uint64_t>(), A<uint64_t>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->AddPresenter(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_presenter() = presenter;
    *request.mutable_resource() = resource;

    EXPECT_NO_THROW(status = m_server->AddPresenter(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, DropPresenter)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::DropPresenterRequest request{};
    flashback::DropPresenterResponse response{};
    flashback::Presenter presenter{};
    flashback::Resource resource{};

    presenter.set_name("Brian Salehi");
    presenter.set_id(1);
    resource.set_id(1);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, drop_presenter(A<uint64_t>(), A<uint64_t>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->DropPresenter(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_presenter() = presenter;
    *request.mutable_resource() = resource;

    EXPECT_NO_THROW(status = m_server->DropPresenter(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, SearchPresenters)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::SearchPresentersRequest request{};
    flashback::SearchPresentersResponse response{};
    std::map<uint64_t, flashback::Presenter> presenters{};
    flashback::Presenter presenter{};
    flashback::Resource resource{};

    presenter.set_name("Brian Salehi");
    presenter.set_id(1);
    resource.set_id(1);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, search_presenters(A<std::string_view>())).Times(1).WillOnce(Return(presenters));

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->SearchPresenters(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    request.set_search_token("Brian Salehi");

    EXPECT_NO_THROW(status = m_server->SearchPresenters(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, RenamePresenter)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::RenamePresenterRequest request{};
    flashback::RenamePresenterResponse response{};
    flashback::Presenter presenter{};

    presenter.set_name("Brian Salehi");
    presenter.set_id(1);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, rename_presenter(A<uint64_t>(), A<std::string>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->RenamePresenter(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_presenter() = presenter;

    EXPECT_NO_THROW(status = m_server->RenamePresenter(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, RemovePresenter)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::RemovePresenterRequest request{};
    flashback::RemovePresenterResponse response{};
    flashback::Presenter presenter{};

    presenter.set_name("Brian Salehi");
    presenter.set_id(1);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, remove_presenter(A<uint64_t>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->RemovePresenter(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_presenter() = presenter;

    EXPECT_NO_THROW(status = m_server->RemovePresenter(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, MergePresenters)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::MergePresentersRequest request{};
    flashback::MergePresentersResponse response{};
    flashback::Presenter source{};
    flashback::Presenter target{};

    source.set_name("Brian Salehi");
    source.set_id(1);
    target.set_name("John Doe");
    target.set_id(1);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, merge_presenters(A<uint64_t>(), A<uint64_t>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->MergePresenters(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_source() = source;
    *request.mutable_target() = target;

    EXPECT_NO_THROW(status = m_server->MergePresenters(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, GetTopics)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::GetTopicsRequest request{};
    flashback::GetTopicsResponse response{};
    flashback::Subject subject{};
    flashback::Topic topic{};
    std::map<uint64_t, flashback::Topic> topics{};

    subject.set_name("C++");
    subject.set_id(1);
    topic.set_name("Coroutines");
    topic.set_position(1);
    topic.set_level(flashback::expertise_level::depth);
    topics.insert({topic.position(), topic});

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, get_topics(A<uint64_t>(), A<flashback::expertise_level>())).Times(1).WillOnce(Return(topics));

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->GetTopics(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_subject() = subject;
    request.set_level(topic.level());

    EXPECT_NO_THROW(status = m_server->GetTopics(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, CreateTopic)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::CreateTopicRequest request{};
    flashback::CreateTopicResponse response{};
    flashback::Subject subject{};
    flashback::Topic topic{};

    subject.set_name("C++");
    subject.set_id(1);
    topic.set_name("Coroutines");
    topic.set_position(1);
    topic.set_level(flashback::expertise_level::depth);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, create_topic(A<uint64_t>(), A<std::string>(), A<flashback::expertise_level>(), A<uint64_t>())).Times(1).WillOnce(Return(topic));

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->CreateTopic(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_subject() = subject;
    *request.mutable_topic() = topic;

    EXPECT_NO_THROW(status = m_server->CreateTopic(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, ReorderTopic)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::ReorderTopicRequest request{};
    flashback::ReorderTopicResponse response{};
    flashback::Subject subject{};
    flashback::Topic topic{};
    flashback::Topic target{};

    subject.set_name("C++");
    subject.set_id(1);
    topic.set_name("Coroutines");
    topic.set_position(1);
    topic.set_level(flashback::expertise_level::depth);
    target.set_name("Reflection");
    target.set_position(1);
    target.set_level(flashback::expertise_level::origin);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, reorder_topic(A<uint64_t>(), A<flashback::expertise_level>(), A<uint64_t>(), A<uint64_t>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->ReorderTopic(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_subject() = subject;
    *request.mutable_topic() = topic;
    *request.mutable_target() = target;

    EXPECT_NO_THROW(status = m_server->ReorderTopic(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, RemoveTopic)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::RemoveTopicRequest request{};
    flashback::RemoveTopicResponse response{};
    flashback::Subject subject{};
    flashback::Topic topic{};

    subject.set_name("C++");
    subject.set_id(1);
    topic.set_name("Coroutines");
    topic.set_position(1);
    topic.set_level(flashback::expertise_level::depth);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, remove_topic(A<uint64_t>(), A<flashback::expertise_level>(), A<uint64_t>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->RemoveTopic(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_subject() = subject;
    *request.mutable_topic() = topic;

    EXPECT_NO_THROW(status = m_server->RemoveTopic(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, MergeTopics)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::MergeTopicsRequest request{};
    flashback::MergeTopicsResponse response{};
    flashback::Subject subject{};
    flashback::Topic source{};
    flashback::Topic target{};

    subject.set_name("C++");
    subject.set_id(1);
    source.set_name("Coroutines");
    source.set_position(1);
    source.set_level(flashback::expertise_level::depth);
    target.set_name("Reflections");
    target.set_position(1);
    target.set_level(flashback::expertise_level::origin);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, merge_topics(A<uint64_t>(), A<flashback::expertise_level>(), A<uint64_t>(), A<uint64_t>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->MergeTopics(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_subject() = subject;
    *request.mutable_source() = source;
    *request.mutable_target() = target;

    EXPECT_NO_THROW(status = m_server->MergeTopics(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, EditTopic)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::EditTopicRequest request{};
    flashback::EditTopicResponse response{};
    flashback::Subject subject{};
    flashback::Topic topic{};

    subject.set_name("C++");
    subject.set_id(1);
    topic.set_name("Coroutines");
    topic.set_position(1);
    topic.set_level(flashback::expertise_level::depth);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, get_topic(A<uint64_t>(), A<flashback::expertise_level>(), A<uint64_t>())).Times(3).WillRepeatedly(Return(topic));

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->EditTopic(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_subject() = subject;
    *request.mutable_topic() = topic;
    flashback::Topic* modified_topic = request.mutable_target();
    *modified_topic = topic;

    EXPECT_NO_THROW(status = m_server->EditTopic(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::ALREADY_EXISTS));

    modified_topic->set_name("Reflection");
    EXPECT_CALL(*m_mock_database, rename_topic(A<uint64_t>(), A<flashback::expertise_level>(), A<uint64_t>(), A<std::string>())).Times(1);
    EXPECT_NO_THROW(status = m_server->EditTopic(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());

    modified_topic->set_name(topic.name());
    modified_topic->set_level(flashback::expertise_level::origin);
    EXPECT_CALL(*m_mock_database, change_topic_level(A<uint64_t>(), A<uint64_t>(), A<flashback::expertise_level>(), A<flashback::expertise_level>())).Times(1);
    EXPECT_NO_THROW(status = m_server->EditTopic(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, MoveTopic)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::MoveTopicRequest request{};
    flashback::MoveTopicResponse response{};
    flashback::Subject source_subject{};
    flashback::Topic source_topic{};
    flashback::Subject target_subject{};
    flashback::Topic target_topic{};

    source_subject.set_name("C");
    source_subject.set_id(1);
    target_subject.set_name("C");
    target_subject.set_id(1);
    source_topic.set_name("Function");
    source_topic.set_position(1);
    source_topic.set_level(flashback::expertise_level::surface);
    target_topic.set_name("Function");
    target_topic.set_position(1);
    target_topic.set_level(flashback::expertise_level::surface);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, move_topic(A<uint64_t>(), A<flashback::expertise_level>(), A<uint64_t>(), A<uint64_t>(), A<uint64_t>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->MoveTopic(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_source_subject() = source_subject;
    *request.mutable_source_topic() = source_topic;
    *request.mutable_target_subject() = target_subject;
    *request.mutable_target_topic() = target_topic;

    EXPECT_NO_THROW(status = m_server->MoveTopic(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, SearchTopics)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::SearchTopicsRequest request{};
    flashback::SearchTopicsResponse response{};
    flashback::Subject subject{};
    flashback::Topic topic{};
    std::map<uint64_t, flashback::Topic> results{};

    subject.set_name("C++");
    subject.set_id(1);
    topic.set_name("Reflections");
    topic.set_position(1);
    topic.set_level(flashback::expertise_level::origin);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, search_topics(A<uint64_t>(), A<flashback::expertise_level>(), A<std::string_view>())).Times(1).WillOnce(Return(results));

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->SearchTopics(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_subject() = subject;
    request.set_level(topic.level());
    request.set_search_token(topic.name());

    EXPECT_NO_THROW(status = m_server->SearchTopics(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, GetSections)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::GetSectionsRequest request{};
    flashback::GetSectionsResponse response{};
    flashback::Resource resource{};
    flashback::Section section{};
    std::map<uint64_t, flashback::Section> sections{};

    resource.set_name("C++ Resource");
    resource.set_id(1);
    section.set_name("Reflections");
    section.set_position(1);
    sections.insert({section.position(), section});

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, get_sections(A<uint64_t>())).Times(1).WillOnce(Return(sections));

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->GetSections(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_resource() = resource;

    EXPECT_NO_THROW(status = m_server->GetSections(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, CreateSection)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::CreateSectionRequest request{};
    flashback::CreateSectionResponse response{};
    flashback::Resource resource{};
    flashback::Section section{};

    resource.set_name("C++ Resource");
    resource.set_id(1);
    section.set_name("Reflections");
    section.set_position(1);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, create_section(A<uint64_t>(), A<uint64_t>(), A<std::string>(), A<std::string>())).Times(1).WillOnce(Return(section));

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->CreateSection(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_resource() = resource;
    *request.mutable_section() = section;

    EXPECT_NO_THROW(status = m_server->CreateSection(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, ReorderSection)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::ReorderSectionRequest request{};
    flashback::ReorderSectionResponse response{};
    flashback::Resource resource{};
    flashback::Section source{};
    flashback::Section target{};

    resource.set_name("C++ Resource");
    resource.set_id(1);
    source.set_name("Reflections");
    source.set_position(4);
    target.set_name("Contracts");
    target.set_position(2);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, reorder_section(A<uint64_t>(), A<uint64_t>(), A<uint64_t>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->ReorderSection(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_resource() = resource;
    *request.mutable_source() = source;
    *request.mutable_target() = target;

    EXPECT_NO_THROW(status = m_server->ReorderSection(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, RemoveSection)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::RemoveSectionRequest request{};
    flashback::RemoveSectionResponse response{};
    flashback::Resource resource{};
    flashback::Section section{};

    resource.set_name("C++ Resource");
    resource.set_id(1);
    section.set_name("Reflections");
    section.set_position(1);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, remove_section(A<uint64_t>(), A<uint64_t>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->RemoveSection(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_resource() = resource;
    *request.mutable_section() = section;

    EXPECT_NO_THROW(status = m_server->RemoveSection(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, MergeSections)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::MergeSectionsRequest request{};
    flashback::MergeSectionsResponse response{};
    flashback::Resource resource{};
    flashback::Section source{};
    flashback::Section target{};

    resource.set_name("C++ Resource");
    resource.set_id(1);
    source.set_name("Reflections");
    source.set_position(1);
    target.set_name("Contracts");
    target.set_position(2);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, merge_sections(A<uint64_t>(), A<uint64_t>(), A<uint64_t>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->MergeSections(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_resource() = resource;
    *request.mutable_source() = source;
    *request.mutable_target() = target;

    EXPECT_NO_THROW(status = m_server->MergeSections(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, EditSection)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::EditSectionRequest request{};
    flashback::EditSectionResponse response{};
    flashback::Resource resource{};
    flashback::Section section{};

    resource.set_name("C++ Resource");
    resource.set_id(1);
    section.set_name("Reflections");
    section.set_position(1);
    section.set_link("https://correct.url");

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, get_section(A<uint64_t>(), A<uint64_t>())).Times(3).WillRepeatedly(Return(section));

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->EditSection(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_resource() = resource;
    flashback::Section* modified_section = request.mutable_section();
    *modified_section = section;

    EXPECT_NO_THROW(status = m_server->EditSection(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::ALREADY_EXISTS));

    modified_section->set_name("Coroutine");
    EXPECT_CALL(*m_mock_database, rename_section(A<uint64_t>(), A<uint64_t>(), A<std::string>())).Times(1);
    EXPECT_NO_THROW(status = m_server->EditSection(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
    modified_section->set_name(section.name());

    modified_section->set_link("https:://modified.com");
    EXPECT_CALL(*m_mock_database, edit_section_link(A<uint64_t>(), A<uint64_t>(), A<std::string>())).Times(1);
    EXPECT_NO_THROW(status = m_server->EditSection(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
    modified_section->set_link(section.link());
}

TEST_F(test_server, MoveSection)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::MoveSectionRequest request{};
    flashback::MoveSectionResponse response{};
    flashback::Resource source_resource{};
    flashback::Section source_section{};
    flashback::Resource target_resource{};
    flashback::Section target_section{};

    source_resource.set_name("C Resource");
    source_resource.set_id(1);
    target_resource.set_name("C++ Resource");
    target_resource.set_id(2);
    source_section.set_name("Reflections");
    source_section.set_position(1);
    target_section.set_name("Coroutine");
    target_section.set_position(2);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, move_section(A<uint64_t>(), A<uint64_t>(), A<uint64_t>(), A<uint64_t>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->MoveSection(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_source_resource() = source_resource;
    *request.mutable_source_section() = source_section;
    *request.mutable_target_resource() = target_resource;
    *request.mutable_target_section() = target_section;

    EXPECT_NO_THROW(status = m_server->MoveSection(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, SearchSections)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::SearchSectionsRequest request{};
    flashback::SearchSectionsResponse response{};
    flashback::Resource resource{};
    flashback::Section section{};
    std::map<uint64_t, flashback::Section> results{};

    resource.set_name("C++ Resource");
    resource.set_id(1);
    section.set_name("Reflections");
    section.set_position(1);
    results.insert({section.position(), section});

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, search_sections(A<uint64_t>(), A<std::string_view>())).Times(1).WillOnce(Return(results));

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->SearchSections(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_resource() = resource;
    request.set_search_token(section.name());

    EXPECT_NO_THROW(status = m_server->SearchSections(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, CreateCard)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::CreateCardRequest request{};
    flashback::CreateCardResponse response{};
    flashback::Card card{};

    auto constexpr state{flashback::Card::draft};
    auto constexpr headline{"Is it worth asking?"};

    card.clear_id();
    card.set_state(state);
    card.set_headline(headline);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, create_card(A<flashback::Card>())).Times(1).WillOnce(Return(card));

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->CreateCard(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_card() = card;

    EXPECT_NO_THROW(status = m_server->CreateCard(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, AddCardToSection)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::AddCardToSectionRequest request{};
    flashback::AddCardToSectionResponse response{};
    flashback::Card card{};
    flashback::Resource resource{};
    flashback::Section section{};
    resource.set_id(1);
    card.set_id(1);
    section.set_position(1);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, add_card_to_section(A<uint64_t>(), A<uint64_t>(), A<uint64_t>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->AddCardToSection(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_card() = card;
    *request.mutable_resource() = resource;
    *request.mutable_section() = section;

    EXPECT_NO_THROW(status = m_server->AddCardToSection(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, AddCardToTopic)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::AddCardToTopicRequest request{};
    flashback::AddCardToTopicResponse response{};
    flashback::Card card{};
    flashback::Subject subject{};
    flashback::Topic topic{};
    subject.set_id(1);
    card.set_id(1);
    topic.set_position(1);
    topic.set_level(flashback::expertise_level::depth);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, add_card_to_topic(A<uint64_t>(), A<uint64_t>(), A<uint64_t>(), A<flashback::expertise_level>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->AddCardToTopic(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_card() = card;
    *request.mutable_subject() = subject;
    *request.mutable_topic() = topic;

    EXPECT_NO_THROW(status = m_server->AddCardToTopic(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, RemoveCard)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::RemoveCardRequest request{};
    flashback::RemoveCardResponse response{};
    flashback::Card card{};

    auto constexpr state{flashback::Card::draft};
    auto constexpr headline{"Is it worth asking?"};

    card.set_id(1);
    card.set_state(state);
    card.set_headline(headline);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, remove_card(A<uint64_t>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->RemoveCard(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_card() = card;

    EXPECT_NO_THROW(status = m_server->RemoveCard(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, MergeCards)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::MergeCardsRequest request{};
    flashback::MergeCardsResponse response{};
    flashback::Card source{};
    flashback::Card target{};

    auto constexpr state{flashback::Card::draft};
    auto constexpr headline{"Is it worth asking?"};

    source.set_id(1);
    source.set_state(state);
    source.set_headline(headline);
    target.set_id(2);
    target.set_state(state);
    target.set_headline(headline);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, merge_cards(A<uint64_t>(), A<uint64_t>(), A<std::string>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->MergeCards(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_source() = source;
    *request.mutable_target() = target;

    EXPECT_NO_THROW(status = m_server->MergeCards(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, SearchCards)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::SearchCardsRequest request{};
    flashback::SearchCardsResponse response{};
    flashback::Card card{};
    flashback::Subject subject{};
    auto constexpr level{flashback::expertise_level::depth};
    std::map<uint64_t, flashback::Card> result{};

    auto constexpr state{flashback::Card::draft};
    auto constexpr headline{"Is it worth asking?"};

    card.set_id(1);
    card.set_state(state);
    card.set_headline(headline);
    subject.set_id(1);
    result.insert({1, card});

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, search_cards(A<uint64_t>(), A<flashback::expertise_level>(), A<std::string_view>())).Times(1).WillOnce(Return(result));

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->SearchCards(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_subject() = subject;
    request.set_level(level);
    request.set_search_token(card.headline());

    EXPECT_NO_THROW(status = m_server->SearchCards(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, GetStudyResources)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::GetStudyResourcesRequest request{};
    flashback::GetStudyResourcesResponse response{};
    std::map<uint64_t, flashback::Resource> result{};
    flashback::Resource resource{};
    resource.set_id(1);
    result.insert({1, resource});

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, get_study_resources(A<uint64_t>())).Times(1).WillOnce(Return(result));

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->GetStudyResources(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;

    EXPECT_NO_THROW(status = m_server->GetStudyResources(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, MoveCardToSection)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::MoveCardToSectionRequest request{};
    flashback::MoveCardToSectionResponse response{};
    flashback::Resource resource{};
    flashback::Section source{};
    flashback::Section target{};
    flashback::Card card{};
    resource.set_id(1);
    source.set_position(1);
    target.set_position(3);
    card.set_id(1);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, move_card_to_section(A<uint64_t>(), A<uint64_t>(), A<uint64_t>(), A<uint64_t>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->MoveCardToSection(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_resource() = resource;
    *request.mutable_source() = source;
    *request.mutable_target() = target;
    *request.mutable_card() = card;

    EXPECT_NO_THROW(status = m_server->MoveCardToSection(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, MarkSectionAsReviewed)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::MarkSectionAsReviewedRequest request{};
    flashback::MarkSectionAsReviewedResponse response{};
    flashback::Resource resource{};
    flashback::Section section{};
    resource.set_id(1);
    section.set_position(1);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, mark_section_as_reviewed(A<uint64_t>(), A<uint64_t>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->MarkSectionAsReviewed(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_resource() = resource;
    *request.mutable_section() = section;

    EXPECT_NO_THROW(status = m_server->MarkSectionAsReviewed(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, GetPracticeCards)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::GetPracticeCardsRequest request{};
    flashback::GetPracticeCardsResponse response{};
    flashback::Roadmap roadmap{};
    flashback::Subject subject{};
    flashback::Topic topic{};
    flashback::Card card{};
    std::vector<flashback::Card> cards{};
    roadmap.set_id(1);
    subject.set_id(1);
    topic.set_position(1);
    topic.set_level(flashback::expertise_level::depth);
    card.set_id(1);
    cards.push_back(card);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, get_practice_cards(A<uint64_t>(), A<uint64_t>(), A<uint64_t>(), A<flashback::expertise_level>(), A<uint64_t>())).Times(1).WillOnce(Return(cards));

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->GetPracticeCards(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_roadmap() = roadmap;
    *request.mutable_subject() = subject;
    *request.mutable_topic() = topic;

    EXPECT_NO_THROW(status = m_server->GetPracticeCards(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, MoveCardToTopic)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::MoveCardToTopicRequest request{};
    flashback::MoveCardToTopicResponse response{};
    flashback::Subject subject{};
    flashback::Topic topic{};
    flashback::Subject target_subject{};
    flashback::Topic target_topic{};
    flashback::Card card{};
    subject.set_id(1);
    topic.set_position(1);
    topic.set_level(flashback::expertise_level::depth);
    target_subject.set_id(2);
    target_topic.set_position(1);
    target_topic.set_level(flashback::expertise_level::origin);
    card.set_id(1);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database,
                move_card_to_topic(A<uint64_t>(), A<uint64_t>(), A<uint64_t>(), A<flashback::expertise_level>(), A<uint64_t>(), A<uint64_t>(), A<flashback::expertise_level>())).
        Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->MoveCardToTopic(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_card() = card;
    *request.mutable_subject() = subject;
    *request.mutable_topic() = topic;
    *request.mutable_target_subject() = target_subject;
    *request.mutable_target_topic() = target_topic;

    EXPECT_NO_THROW(status = m_server->MoveCardToTopic(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, CreateAssessment)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::CreateAssessmentRequest request{};
    flashback::CreateAssessmentResponse response{};
    flashback::Subject subject{};
    flashback::Topic topic{};
    flashback::Card card{};
    subject.set_id(1);
    topic.set_position(1);
    topic.set_level(flashback::expertise_level::depth);
    card.set_id(1);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, create_assessment(A<uint64_t>(), A<flashback::expertise_level>(), A<uint64_t>(), A<uint64_t>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->CreateAssessment(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_subject() = subject;
    *request.mutable_topic() = topic;
    *request.mutable_card() = card;

    EXPECT_NO_THROW(status = m_server->CreateAssessment(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, GetAssessments)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::GetAssessmentsRequest request{};
    flashback::GetAssessmentsResponse response{};
    flashback::Subject subject{};
    flashback::Topic topic{};
    flashback::Card card{};
    flashback::Assessment assessment{};
    std::vector<flashback::Assessment> assessments{};
    subject.set_id(1);
    topic.set_position(1);
    topic.set_level(flashback::expertise_level::depth);
    card.set_id(1);
    *assessment.mutable_card() = card;
    assessment.set_assimilations(2);
    assessments.push_back(assessment);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, get_assessments(A<uint64_t>(), A<uint64_t>(), A<flashback::expertise_level>(), A<uint64_t>())).Times(1).WillOnce(Return(assessments));

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->GetAssessments(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_subject() = subject;
    *request.mutable_topic() = topic;

    EXPECT_NO_THROW(status = m_server->GetAssessments(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, ExpandAssessment)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::ExpandAssessmentRequest request{};
    flashback::ExpandAssessmentResponse response{};
    flashback::Subject subject{};
    flashback::Topic topic{};
    flashback::Card card{};
    subject.set_id(1);
    topic.set_position(1);
    topic.set_level(flashback::expertise_level::depth);
    card.set_id(1);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, expand_assessment(A<uint64_t>(), A<uint64_t>(), A<flashback::expertise_level>(), A<uint64_t>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->ExpandAssessment(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_subject() = subject;
    *request.mutable_topic() = topic;
    *request.mutable_card() = card;

    EXPECT_NO_THROW(status = m_server->ExpandAssessment(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, DiminishAssessment)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::DiminishAssessmentRequest request{};
    flashback::DiminishAssessmentResponse response{};
    flashback::Subject subject{};
    flashback::Topic topic{};
    flashback::Card card{};
    subject.set_id(1);
    topic.set_position(1);
    topic.set_level(flashback::expertise_level::depth);
    card.set_id(1);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, diminish_assessment(A<uint64_t>(), A<uint64_t>(), A<flashback::expertise_level>(), A<uint64_t>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->DiminishAssessment(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_subject() = subject;
    *request.mutable_topic() = topic;
    *request.mutable_card() = card;

    EXPECT_NO_THROW(status = m_server->DiminishAssessment(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, IsAssimilated)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::IsAssimilatedRequest request{};
    flashback::IsAssimilatedResponse response{};
    flashback::Subject subject{};
    flashback::Topic topic{};
    subject.set_id(1);
    topic.set_position(1);
    topic.set_level(flashback::expertise_level::depth);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, is_assimilated(A<uint64_t>(), A<uint64_t>(), A<flashback::expertise_level>(), A<uint64_t>())).Times(1).WillOnce(Return(true));

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->IsAssimilated(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_subject() = subject;
    *request.mutable_topic() = topic;

    EXPECT_NO_THROW(status = m_server->IsAssimilated(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, EditCard)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::EditCardRequest request{};
    flashback::EditCardResponse response{};
    flashback::Card card{};
    auto constexpr headline{"Is it worth criticizing it?"};
    auto constexpr state{flashback::Card::draft};
    card.set_id(1);
    card.set_headline(headline);
    card.set_state(state);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, get_card(A<uint64_t>())).Times(2).WillRepeatedly(Return(card));

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->EditCard(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    flashback::Card* modified_card = request.mutable_card();
    *modified_card = card;

    EXPECT_NO_THROW(status = m_server->EditCard(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::ALREADY_EXISTS));

    modified_card->set_headline("Is this different?");
    EXPECT_CALL(*m_mock_database, edit_card_headline(A<uint64_t>(), A<std::string>()));
    EXPECT_NO_THROW(status = m_server->EditCard(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
    modified_card->set_headline(headline);
}

TEST_F(test_server, CreateBlock)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::CreateBlockRequest request{};
    flashback::CreateBlockResponse response{};
    flashback::Card card{};
    flashback::Block block{};
    auto constexpr headline{"Is it worth criticizing it?"};
    auto constexpr state{flashback::Card::draft};
    auto constexpr type{flashback::Block::text};
    auto constexpr extension{"cpp"};
    auto constexpr metadata{"tip"};
    auto constexpr content{"auto main() -> int { }"};
    card.set_id(1);
    card.set_headline(headline);
    card.set_state(state);
    block.set_position(1);
    block.set_type(type);
    block.set_extension(extension);
    block.set_content(content);
    block.set_metadata(metadata);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, create_block(A<uint64_t>(), A<flashback::Block>())).Times(1).WillOnce(Return(block));

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->CreateBlock(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_card() = card;
    *request.mutable_block() = block;

    EXPECT_NO_THROW(status = m_server->CreateBlock(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, GetBlocks)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::GetBlocksRequest request{};
    flashback::GetBlocksResponse response{};
    flashback::Card card{};
    flashback::Block block{};
    std::map<uint64_t, flashback::Block> blocks{};

    auto constexpr headline{"Is it worth criticizing it?"};
    auto constexpr state{flashback::Card::draft};
    auto constexpr type{flashback::Block::text};
    auto constexpr extension{"cpp"};
    auto constexpr metadata{"tip"};
    auto constexpr content{"auto main() -> int { }"};
    card.set_id(1);
    card.set_headline(headline);
    card.set_state(state);
    block.set_position(1);
    block.set_type(type);
    block.set_extension(extension);
    block.set_content(content);
    block.set_metadata(metadata);
    blocks.insert({block.position(), block});

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, get_blocks(A<uint64_t>())).Times(1).WillOnce(Return(blocks));

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->GetBlocks(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_card() = card;

    EXPECT_NO_THROW(status = m_server->GetBlocks(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, RemoveBlock)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::RemoveBlockRequest request{};
    flashback::RemoveBlockResponse response{};
    flashback::Card card{};
    flashback::Block block{};
    auto constexpr headline{"Is it worth criticizing it?"};
    auto constexpr state{flashback::Card::draft};
    auto constexpr type{flashback::Block::text};
    auto constexpr extension{"cpp"};
    auto constexpr metadata{"tip"};
    auto constexpr content{"auto main() -> int { }"};
    card.set_id(1);
    card.set_headline(headline);
    card.set_state(state);
    block.set_position(1);
    block.set_type(type);
    block.set_extension(extension);
    block.set_content(content);
    block.set_metadata(metadata);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, remove_block(A<uint64_t>(), A<uint64_t>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->RemoveBlock(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_card() = card;
    *request.mutable_block() = block;

    EXPECT_NO_THROW(status = m_server->RemoveBlock(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, EditBlock)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::EditBlockRequest request{};
    flashback::EditBlockResponse response{};
    flashback::Card card{};
    flashback::Block block{};
    auto constexpr headline{"Is it worth criticizing it?"};
    auto constexpr state{flashback::Card::draft};
    auto constexpr type{flashback::Block::text};
    auto constexpr extension{"cpp"};
    auto constexpr metadata{"tip"};
    auto constexpr content{"auto main() -> int { }"};
    card.set_id(1);
    card.set_headline(headline);
    card.set_state(state);
    block.set_position(1);
    block.set_type(type);
    block.set_extension(extension);
    block.set_content(content);
    block.set_metadata(metadata);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, get_block(A<uint64_t>(), A<uint64_t>())).Times(5).WillRepeatedly(Return(block));

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->EditBlock(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_card() = card;
    flashback::Block* modified_block = request.mutable_block();
    *modified_block = block;

    EXPECT_NO_THROW(status = m_server->EditBlock(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::ALREADY_EXISTS));

    modified_block->set_type(flashback::Block::code);
    EXPECT_CALL(*m_mock_database, change_block_type(A<uint64_t>(), A<uint64_t>(), A<flashback::Block::content_type>())).Times(1);
    EXPECT_NO_THROW(status = m_server->EditBlock(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
    modified_block->set_type(type);

    modified_block->set_extension("sh");
    EXPECT_CALL(*m_mock_database, edit_block_extension(A<uint64_t>(), A<uint64_t>(), A<std::string>())).Times(1);
    EXPECT_NO_THROW(status = m_server->EditBlock(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
    modified_block->set_extension(extension);

    modified_block->set_content("print('');");
    EXPECT_CALL(*m_mock_database, edit_block_content(A<uint64_t>(), A<uint64_t>(), A<std::string>())).Times(1);
    EXPECT_NO_THROW(status = m_server->EditBlock(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
    modified_block->set_content(content);

    modified_block->set_metadata("hint");
    EXPECT_CALL(*m_mock_database, edit_block_metadata(A<uint64_t>(), A<uint64_t>(), A<std::string>())).Times(1);
    EXPECT_NO_THROW(status = m_server->EditBlock(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
    modified_block->set_metadata(metadata);
}

TEST_F(test_server, ReorderBlock)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::ReorderBlockRequest request{};
    flashback::ReorderBlockResponse response{};
    flashback::Card card{};
    flashback::Block block{};
    flashback::Block target{};
    auto constexpr headline{"Is it worth criticizing it?"};
    auto constexpr state{flashback::Card::draft};
    auto constexpr type{flashback::Block::text};
    auto constexpr extension{"cpp"};
    auto constexpr metadata{"tip"};
    auto constexpr content{"auto main() -> int { }"};
    card.set_id(1);
    card.set_headline(headline);
    card.set_state(state);
    block.set_position(1);
    block.set_type(type);
    block.set_extension(extension);
    block.set_content(content);
    block.set_metadata(metadata);
    target = block;
    target.set_position(3);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, reorder_block(A<uint64_t>(), A<uint64_t>(), A<uint64_t>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->ReorderBlock(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_card() = card;
    *request.mutable_block() = block;
    *request.mutable_target() = target;

    EXPECT_NO_THROW(status = m_server->ReorderBlock(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, MergeBlocks)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::MergeBlocksRequest request{};
    flashback::MergeBlocksResponse response{};
    flashback::Card card{};
    flashback::Block block{};
    flashback::Block target{};
    auto constexpr headline{"Is it worth criticizing it?"};
    auto constexpr state{flashback::Card::draft};
    auto constexpr type{flashback::Block::text};
    auto constexpr extension{"cpp"};
    auto constexpr metadata{"tip"};
    auto constexpr content{"auto main() -> int { }"};
    card.set_id(1);
    card.set_headline(headline);
    card.set_state(state);
    block.set_position(1);
    block.set_type(type);
    block.set_extension(extension);
    block.set_content(content);
    block.set_metadata(metadata);
    target = block;
    target.set_position(3);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, merge_blocks(A<uint64_t>(), A<uint64_t>(), A<uint64_t>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->MergeBlocks(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_card() = card;
    *request.mutable_block() = block;
    *request.mutable_target() = target;

    EXPECT_NO_THROW(status = m_server->MergeBlocks(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, SplitBlock)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::SplitBlockRequest request{};
    flashback::SplitBlockResponse response{};
    flashback::Card card{};
    flashback::Block block{};
    std::map<uint64_t, flashback::Block> blocks{};
    auto constexpr headline{"Is it worth criticizing it?"};
    auto constexpr state{flashback::Card::draft};
    auto constexpr type{flashback::Block::text};
    auto constexpr extension{"cpp"};
    auto constexpr metadata{"tip"};
    auto constexpr content{"auto main() -> int { }"};
    card.set_id(1);
    card.set_headline(headline);
    card.set_state(state);
    block.set_position(1);
    block.set_type(type);
    block.set_extension(extension);
    block.set_content(content);
    block.set_metadata(metadata);
    blocks.insert({1, block});
    blocks.insert({2, block});

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, split_block(A<uint64_t>(), A<uint64_t>())).Times(1).WillOnce(Return(blocks));

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->SplitBlock(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_card() = card;
    *request.mutable_block() = block;

    EXPECT_NO_THROW(status = m_server->SplitBlock(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, MarkCardAsReviewed)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::MarkCardAsReviewedRequest request{};
    flashback::MarkCardAsReviewedResponse response{};
    flashback::Card card{};
    auto constexpr headline{"Is it worth criticizing it?"};
    auto constexpr state{flashback::Card::draft};
    card.set_id(1);
    card.set_headline(headline);
    card.set_state(state);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, mark_card_as_reviewed(A<uint64_t>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->MarkCardAsReviewed(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_card() = card;

    EXPECT_NO_THROW(status = m_server->MarkCardAsReviewed(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, Study)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::StudyRequest request{};
    flashback::StudyResponse response{};
    flashback::Card card{};
    auto constexpr headline{"Is it worth criticizing it?"};
    auto constexpr state{flashback::Card::draft};
    card.set_id(1);
    card.set_headline(headline);
    card.set_state(state);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, study(A<uint64_t>(), A<uint64_t>(), A<std::chrono::seconds>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->Study(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_card() = card;
    request.set_duration(100);

    EXPECT_NO_THROW(status = m_server->Study(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, MakeProgress)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::MakeProgressRequest request{};
    flashback::MakeProgressResponse response{};
    flashback::Card card{};
    auto constexpr headline{"Is it worth criticizing it?"};
    auto constexpr state{flashback::Card::draft};
    card.set_id(1);
    card.set_headline(headline);
    card.set_state(state);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, make_progress(A<uint64_t>(), A<uint64_t>(), A<uint64_t>(), A<flashback::practice_mode>())).Times(1);

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->MakeProgress(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;
    *request.mutable_card() = card;
    request.set_duration(100);
    request.set_mode(flashback::practice_mode::progressive);

    EXPECT_NO_THROW(status = m_server->MakeProgress(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, GetProgressWeight)
{
    grpc::Status status{};
    grpc::ServerContext context{};
    flashback::GetProgressWeightRequest request{};
    flashback::GetProgressWeightResponse response{};
    std::vector<flashback::Weight> weights{};
    flashback::Weight weight{};
    flashback::Resource resource{};
    resource.set_id(1);
    auto constexpr percentage{42};
    *weight.mutable_resource() = resource;
    weight.set_percentage(percentage);

    EXPECT_CALL(*m_mock_database, get_user(A<std::string_view>(), A<std::string_view>())).WillRepeatedly(Invoke([this]() { return std::make_unique<flashback::User>(*m_user); }));
    EXPECT_CALL(*m_mock_database, get_progress_weight(A<uint64_t>())).Times(1).WillOnce(Return(weights));

    request.clear_user();
    EXPECT_NO_THROW(status = m_server->GetProgressWeight(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsFalse());
    EXPECT_THAT(status.error_message().empty(), IsFalse());
    EXPECT_THAT(status.error_code(), Eq(grpc::StatusCode::UNAUTHENTICATED));

    *request.mutable_user() = *m_user;

    EXPECT_NO_THROW(status = m_server->GetProgressWeight(&context, &request, &response));
    EXPECT_THAT(status.ok(), IsTrue());
    EXPECT_THAT(status.error_message(), IsEmpty());
}

TEST_F(test_server, GetSectionCards)
{
}

TEST_F(test_server, GetTopicCards)
{
}
