#include <memory>
#include <string>
#include <optional>
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include <flashback/mock_database.hpp>
#include <flashback/exception.hpp>
#include <flashback/server.hpp>

class test_server: public testing::Test
{
public:
    void SetUp() override
    {
        m_mock_database = std::make_shared<flashback::mock_database>();
        m_server_context = std::make_unique<grpc::ServerContext>();
        m_server = std::make_shared<flashback::server>(m_mock_database);
        m_user = std::make_shared<flashback::User>();
        m_user->set_id(1);
        m_user->set_email("user@flashback.eu.com");
        m_user->set_name("Flashback Test User");
        m_user->set_password(R"(strong password)");
        m_user->set_device(R"(aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee)");
        m_user->set_hash(R"($argon2id$v=19$m=262144,t=3,p=1$uxpOdV39XaKTf+IjPWX8ZQ$QVfEV1ZyXWMUyUw04PbEx/SjJDxbx9t+AhYAztFATlg)");
        m_user->set_token(R"(iNFzgSaY2W+q42gM9lNVbB13v0odiLy6WnHbInbuvvE)");
    }

protected:
    std::shared_ptr<flashback::server> m_server{nullptr};
    std::shared_ptr<flashback::mock_database> m_mock_database{nullptr};
    std::shared_ptr<flashback::User> m_user{nullptr};
    std::shared_ptr<grpc::ServerContext> m_server_context{nullptr};
};

TEST_F(test_server, SignUpNonExistingUser)
{
    grpc::Status status{};
    auto const signup_request{std::make_unique<flashback::SignUpRequest>()};
    auto const signup_response{std::make_unique<flashback::SignUpResponse>()};

    auto user{std::make_unique<flashback::User>()};
    user->set_name(m_user->name());
    user->set_email(m_user->email());
    user->set_password(m_user->password());
    user->set_device(m_user->device());

    EXPECT_EQ(user->id(), 0) << "User ID should be unknown to client at any point of time";
    EXPECT_FALSE(user->name().empty()) << "Name is required for registration";
    EXPECT_FALSE(user->email().empty()) << "Email is required for registration";
    EXPECT_FALSE(user->password().empty()) << "Password is required for registration";
    EXPECT_FALSE(user->device().empty()) << "Device ID should have been generated by the client";
    EXPECT_TRUE(user->hash().empty()) << "Hash should be unknown to client at any point of time";
    EXPECT_TRUE(user->token().empty()) << "Token will be generated after sign in, so it will remain empty during sign up";

    EXPECT_CALL(*m_mock_database, user_exists(user->email())).Times(1).WillOnce(testing::Return(false));
    EXPECT_CALL(*m_mock_database, create_user(user->name(), user->email(), testing::_)).Times(1).WillOnce(testing::Return(1));

    signup_request->set_allocated_user(user.release());

    EXPECT_NO_THROW(status = m_server->SignUp(m_server_context.get(), signup_request.get(), signup_response.get()));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(signup_response->success());
    EXPECT_TRUE(signup_response->has_user());
    EXPECT_EQ(signup_response->user().id(), 0) << "Client ID should be unknown to client";
    EXPECT_TRUE(signup_response->user().hash().empty()) << "Hash should never be leaked into client side";
    EXPECT_FALSE(signup_response->user().name().empty());
    EXPECT_FALSE(signup_response->user().email().empty());
    EXPECT_FALSE(signup_response->user().device().empty());
    EXPECT_TRUE(signup_response->user().token().empty()) << "Token should be generated after sign in";
    EXPECT_TRUE(signup_response->user().password().empty()) << "Password should be cleared out after sign up";
}

TEST_F(test_server, SignUpExistingUser)
{
    EXPECT_CALL(*m_mock_database, user_exists(m_user->email())).Times(1).WillOnce(testing::Return(true));
    EXPECT_CALL(*m_mock_database, create_user).Times(0);

    grpc::Status status{};
    auto const request{std::make_unique<flashback::SignUpRequest>()};
    auto const response{std::make_unique<flashback::SignUpResponse>()};

    auto user{std::make_unique<flashback::User>()};
    user->set_name(m_user->name());
    user->set_email(m_user->email());
    user->set_password(m_user->password());
    user->set_device(m_user->device());

    EXPECT_EQ(user->id(), 0) << "User ID should be unknown to client at any point of time";
    EXPECT_FALSE(user->name().empty()) << "Name is required for registration";
    EXPECT_FALSE(user->email().empty()) << "Email is required for registration";
    EXPECT_FALSE(user->password().empty()) << "Password is required for registration";
    EXPECT_FALSE(user->device().empty()) << "Device ID should have been generated by the client";
    EXPECT_TRUE(user->hash().empty()) << "Hash should be unknown to client at any point of time";
    EXPECT_TRUE(user->token().empty()) << "Token will be generated after sign in, so it will remain empty during sign up";

    request->set_allocated_user(user.release());

    EXPECT_NO_THROW(status = m_server->SignUp(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response->success()) << "Signing up a user that already exists should fail";
    EXPECT_FALSE(response->has_user());
    EXPECT_EQ(response->user().id(), 0);
    EXPECT_TRUE(response->user().name().empty());
    EXPECT_TRUE(response->user().email().empty());
    EXPECT_TRUE(response->user().device().empty());
    EXPECT_TRUE(response->user().hash().empty());
    EXPECT_TRUE(response->user().password().empty());
    EXPECT_TRUE(response->user().token().empty());
}

TEST_F(test_server, SignUpWithIncompleteCredentials)
{
    grpc::Status status{};
    auto user{std::make_unique<flashback::User>()};
    auto const request{std::make_unique<flashback::SignUpRequest>()};
    auto const response{std::make_unique<flashback::SignUpResponse>()};

    EXPECT_FALSE(response->has_user());
    EXPECT_EQ(user->id(), 0);
    EXPECT_TRUE(user->hash().empty());
    EXPECT_TRUE(user->name().empty());
    EXPECT_TRUE(user->email().empty());
    EXPECT_TRUE(user->device().empty());
    EXPECT_TRUE(user->password().empty());

    EXPECT_CALL(*m_mock_database, user_exists(m_user->email())).Times(0);
    EXPECT_CALL(*m_mock_database, create_user).Times(0);

    EXPECT_NO_THROW(status = m_server->SignUp(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response->success()) << "Signing up with an undefined user should fail";
    EXPECT_FALSE(response->has_user());

    request->set_allocated_user(user.release());
    EXPECT_NO_THROW(status = m_server->SignUp(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response->success()) << "Signing up with a user without a name should fail";
    EXPECT_FALSE(response->has_user());

    user = std::make_unique<flashback::User>();
    user->set_name(m_user->name());
    request->set_allocated_user(user.release());
    EXPECT_NO_THROW(status = m_server->SignUp(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response->success()) << "Signing up with a user without email should fail";
    EXPECT_FALSE(response->has_user());

    user = std::make_unique<flashback::User>();
    user->set_name(m_user->name());
    user->set_email(m_user->email());
    request->set_allocated_user(user.release());
    EXPECT_NO_THROW(status = m_server->SignUp(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response->success()) << "Signing up with a user without device should fail";
    EXPECT_FALSE(response->has_user());

    user = std::make_unique<flashback::User>();
    user->set_name(m_user->name());
    user->set_email(m_user->email());
    user->set_device(m_user->device());
    request->set_allocated_user(user.release());
    EXPECT_NO_THROW(status = m_server->SignUp(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response->success()) << "Signing up with a user without password should fail";
    EXPECT_FALSE(response->has_user());
}

TEST_F(test_server, SignIn)
{
    auto request{std::make_unique<flashback::SignInRequest>()};
    auto response{std::make_unique<flashback::SignInResponse>()};
    auto user_before_signin{std::make_unique<flashback::User>()};
    auto user_after_signin{std::make_unique<flashback::User>()};

    user_before_signin->set_name(m_user->name());
    user_before_signin->set_email(m_user->email());
    user_before_signin->set_password(m_user->password());
    user_before_signin->set_device(m_user->device());

    user_after_signin->set_id(m_user->id());
    user_after_signin->set_name(m_user->name());
    user_after_signin->set_email(m_user->email());
    user_after_signin->set_device(m_user->device());
    user_after_signin->set_token(m_user->token());
    user_after_signin->clear_password();
    user_after_signin->set_hash(m_user->hash());

    EXPECT_EQ(user_before_signin->id(), 0);
    EXPECT_FALSE(user_before_signin->name().empty());
    EXPECT_FALSE(user_before_signin->email().empty());
    EXPECT_FALSE(user_before_signin->password().empty());
    EXPECT_FALSE(user_before_signin->device().empty());
    EXPECT_TRUE(user_before_signin->token().empty()) << "Token should be generated after signing in";
    EXPECT_TRUE(user_before_signin->hash().empty()) << "Hash must be cleared after sign in";

    EXPECT_EQ(user_after_signin->id(), m_user->id()) << "Client ID will be used internally by sign in but will not be returned";
    EXPECT_FALSE(user_after_signin->name().empty()) << "Name is untouched after sign in";
    EXPECT_FALSE(user_after_signin->email().empty()) << "Email is untouched after sign in";
    EXPECT_FALSE(user_after_signin->device().empty()) << "Device ID should be generated by the client before signing in";
    EXPECT_FALSE(user_after_signin->token().empty()) << "Token should be generated after signing in";
    EXPECT_TRUE(user_after_signin->password().empty()) << "Password is not stored in database, so it will be returned empty by database";
    EXPECT_FALSE(user_after_signin->hash().empty()) << "Hash will be used internally by sign up function but will not return";

    EXPECT_CALL(*m_mock_database, user_exists(m_user->email())).Times(1).WillOnce(testing::Return(true));
    EXPECT_CALL(*m_mock_database, get_user(m_user->email())).Times(1).WillOnce(testing::Return(std::move(user_after_signin)));
    EXPECT_CALL(*m_mock_database, create_session(m_user->id(), testing::A<std::string_view>(), m_user->device())).Times(1).WillOnce(testing::Return(true));

    request->set_allocated_user(user_before_signin.release());
    EXPECT_NO_THROW(m_server->SignIn(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(response->success());
    EXPECT_TRUE(response->has_user());
    EXPECT_EQ(response->user().id(), 0) << "Client ID should be unknown to client";
    EXPECT_FALSE(response->user().name().empty());
    EXPECT_FALSE(response->user().email().empty());
    EXPECT_FALSE(response->user().device().empty());
    EXPECT_FALSE(response->user().token().empty()) << "Token should have been generated after signing in";
    EXPECT_TRUE(response->user().password().empty()) << "Password should have been cleared after signing in";
    EXPECT_TRUE(response->user().hash().empty()) << "Hash should never be leaked to client side";
}

TEST_F(test_server, SignInWithInvalidCredentials)
{
    auto request{std::make_unique<flashback::SignInRequest>()};
    auto response{std::make_unique<flashback::SignInResponse>()};
    auto user_before_signin{std::make_unique<flashback::User>()};
    auto const user_after_signin{std::make_unique<flashback::User>()};

    user_before_signin->set_name(m_user->name());
    user_before_signin->set_email(m_user->email());
    user_before_signin->set_password(m_user->password().substr(0, m_user->password().size() / 2));
    user_before_signin->set_device(m_user->device());

    user_after_signin->set_id(m_user->id());
    user_after_signin->set_name(m_user->name());
    user_after_signin->set_email(m_user->email());
    user_after_signin->set_device(m_user->device());
    user_after_signin->set_token(m_user->token());
    user_after_signin->clear_password();
    user_after_signin->set_hash(m_user->hash());

    EXPECT_EQ(user_before_signin->id(), 0);
    EXPECT_FALSE(user_before_signin->name().empty());
    EXPECT_FALSE(user_before_signin->email().empty());
    EXPECT_FALSE(user_before_signin->password().empty());
    EXPECT_FALSE(user_before_signin->device().empty());
    EXPECT_TRUE(user_before_signin->token().empty()) << "Token should be generated after signing in";
    EXPECT_TRUE(user_before_signin->hash().empty()) << "Hash must be cleared after sign in";

    EXPECT_EQ(user_after_signin->id(), m_user->id()) << "Client ID will be used internally by sign in but will not be returned";
    EXPECT_FALSE(user_after_signin->name().empty()) << "Name is untouched after sign in";
    EXPECT_FALSE(user_after_signin->email().empty()) << "Email is untouched after sign in";
    EXPECT_FALSE(user_after_signin->device().empty()) << "Device ID should be generated by the client before signing in";
    EXPECT_FALSE(user_after_signin->token().empty()) << "Token should be generated after signing in";
    EXPECT_TRUE(user_after_signin->password().empty()) << "Password is not stored in database, so it will be returned empty from database";
    EXPECT_FALSE(user_after_signin->hash().empty()) << "Hash will be used internally by sign up function but will not return";

    EXPECT_CALL(*m_mock_database, user_exists(m_user->email())).Times(1).WillOnce(testing::Return(true));
    EXPECT_CALL(*m_mock_database, get_user(m_user->email())).Times(1).WillOnce(testing::Return(std::make_unique<flashback::User>(*user_after_signin)));
    EXPECT_CALL(*m_mock_database, create_session(m_user->id(), testing::A<std::string_view>(), m_user->device())).Times(0);

    request->set_allocated_user(user_before_signin.release());
    EXPECT_NO_THROW(m_server->SignIn(m_server_context.get(), request.get(), response.get()));
    EXPECT_FALSE(response->success());
    EXPECT_FALSE(response->has_user());
}

TEST_F(test_server, SignInWithIncompleteCredentials)
{
    EXPECT_CALL(*m_mock_database, user_exists(m_user->email())).Times(0);
    EXPECT_CALL(*m_mock_database, get_user(m_user->email())).Times(0);
    EXPECT_CALL(*m_mock_database, create_session(m_user->id(), testing::A<std::string_view>(), m_user->device())).Times(0);

    auto const request{std::make_unique<flashback::SignInRequest>()};
    auto const response{std::make_unique<flashback::SignInResponse>()};

    std::unique_ptr<flashback::User> user{nullptr};
    EXPECT_EQ(user, nullptr);
    EXPECT_NO_THROW(m_server->SignIn(m_server_context.get(), request.get(), response.get()));
    EXPECT_FALSE(response->success());
    EXPECT_FALSE(response->has_user());

    user = std::make_unique<flashback::User>();
    EXPECT_EQ(user->id(), 0);
    EXPECT_TRUE(user->name().empty());
    EXPECT_TRUE(user->email().empty());
    EXPECT_TRUE(user->password().empty());
    EXPECT_TRUE(user->device().empty());
    EXPECT_TRUE(user->token().empty());
    EXPECT_TRUE(user->hash().empty());
    request->set_allocated_user(user.release());
    EXPECT_NO_THROW(m_server->SignIn(m_server_context.get(), request.get(), response.get()));
    EXPECT_FALSE(response->success());
    EXPECT_FALSE(response->has_user());

    user = std::make_unique<flashback::User>();
    user->set_name(m_user->name());
    EXPECT_EQ(user->id(), 0);
    EXPECT_FALSE(user->name().empty());
    EXPECT_TRUE(user->email().empty());
    EXPECT_TRUE(user->password().empty());
    EXPECT_TRUE(user->device().empty());
    EXPECT_TRUE(user->token().empty());
    EXPECT_TRUE(user->hash().empty());
    request->set_allocated_user(user.release());
    EXPECT_NO_THROW(m_server->SignIn(m_server_context.get(), request.get(), response.get()));
    EXPECT_FALSE(response->success());
    EXPECT_FALSE(response->has_user());

    user = std::make_unique<flashback::User>();
    user->set_name(m_user->name());
    user->set_email(m_user->email());
    EXPECT_EQ(user->id(), 0);
    EXPECT_FALSE(user->name().empty());
    EXPECT_FALSE(user->email().empty());
    EXPECT_TRUE(user->password().empty());
    EXPECT_TRUE(user->device().empty());
    EXPECT_TRUE(user->token().empty());
    EXPECT_TRUE(user->hash().empty());
    request->set_allocated_user(user.release());
    EXPECT_NO_THROW(m_server->SignIn(m_server_context.get(), request.get(), response.get()));
    EXPECT_FALSE(response->success());
    EXPECT_FALSE(response->has_user());

    user = std::make_unique<flashback::User>();
    user->set_name(m_user->name());
    user->set_email(m_user->email());
    user->set_password(m_user->password());
    EXPECT_EQ(user->id(), 0);
    EXPECT_FALSE(user->name().empty());
    EXPECT_FALSE(user->email().empty());
    EXPECT_FALSE(user->password().empty());
    EXPECT_TRUE(user->device().empty());
    EXPECT_TRUE(user->token().empty());
    EXPECT_TRUE(user->hash().empty());
    request->set_allocated_user(user.release());
    EXPECT_NO_THROW(m_server->SignIn(m_server_context.get(), request.get(), response.get()));
    EXPECT_FALSE(response->success());
    EXPECT_FALSE(response->has_user());
}

TEST_F(test_server, CreateRoadmap)
{
    std::string roadmap_name{"Bug Driven Developer"};
    std::string name_with_quotes{"O'Reilly Book Reader"};
    grpc::Status status{};
    auto request{std::make_unique<flashback::CreateRoadmapRequest>()};
    auto response{std::make_unique<flashback::CreateRoadmapResponse>()};

    EXPECT_CALL(*m_mock_database, create_roadmap(roadmap_name)).Times(1).WillOnce(testing::Return(1));
    EXPECT_CALL(*m_mock_database, create_roadmap(name_with_quotes)).Times(1).WillOnce(testing::Return(2));
    EXPECT_CALL(*m_mock_database, get_user(m_user->token(), m_user->device())).Times(4).WillOnce(testing::Return(nullptr)).WillOnce(
        testing::Return(std::make_unique<flashback::User>(*m_user))).WillOnce(testing::Return(nullptr)).WillOnce(
        testing::Return(std::make_unique<flashback::User>(*m_user)));

    request->set_name(roadmap_name);
    EXPECT_NO_THROW(status = m_server->CreateRoadmap(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(status.ok());
    EXPECT_FALSE(response->has_roadmap()) << "User is not set, so the request should be declined";
    EXPECT_EQ(response->roadmap().id(), 0);
    EXPECT_TRUE(response->roadmap().name().empty());

    request->set_allocated_user(std::make_unique<flashback::User>(*m_user).release());
    EXPECT_NO_THROW(status = m_server->CreateRoadmap(m_server_context.get(), request.get(), response.get()));
    EXPECT_FALSE(response->has_roadmap()) << "User is set but session is invalid, therefore the request should be declined";
    EXPECT_EQ(response->roadmap().id(), 0);
    EXPECT_TRUE(response->roadmap().name().empty());

    request->set_allocated_user(std::make_unique<flashback::User>(*m_user).release());
    EXPECT_NO_THROW(status = m_server->CreateRoadmap(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(response->has_roadmap()) << "User is set and session is valid, therefore the request should be responded";
    EXPECT_GT(response->roadmap().id(), 0);
    EXPECT_EQ(response->roadmap().name(), roadmap_name);

    request->clear_name();
    EXPECT_NO_THROW(m_server->CreateRoadmap(m_server_context.get(), request.get(), response.get()));
    EXPECT_FALSE(response->has_roadmap()) << "Creating a roadmap with empty name should fail";
    EXPECT_EQ(response->roadmap().id(), 0);

    request->set_name(name_with_quotes);
    EXPECT_NO_THROW(status = m_server->CreateRoadmap(m_server_context.get(), request.get(), response.get()));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response->has_roadmap()) << "Roadmaps with quotes in their names should be allowed";
    EXPECT_GT(response->roadmap().id(), 0);
    EXPECT_EQ(response->roadmap().name(), name_with_quotes);
}

TEST_F(test_server, AssignRoadmap)
{
    auto request{std::make_unique<flashback::AssignRoadmapRequest>()};
    auto response{std::make_unique<flashback::AssignRoadmapResponse>()};
    auto requesting_user{std::make_unique<flashback::User>(*m_user)};
    auto database_retrieved_user{std::make_unique<flashback::User>(*m_user)};
    auto roadmap{std::make_unique<flashback::Roadmap>()};

    EXPECT_CALL(*m_mock_database, get_user(testing::A<std::string_view>(), testing::A<std::string_view>())).Times(1).WillOnce(
        testing::Return(std::make_unique<flashback::User>(*database_retrieved_user)));
    EXPECT_CALL(*m_mock_database, assign_roadmap(testing::A<uint64_t>(), testing::A<uint64_t>())).Times(1);

    EXPECT_FALSE(request->has_roadmap());
    EXPECT_FALSE(request->has_user());
    EXPECT_NO_THROW(m_server->AssignRoadmap(m_server_context.get(), request.get(), response.get()));

    roadmap->set_id(1);
    roadmap->set_name("Overtime Working Specialist");
    request->set_allocated_roadmap(roadmap.release());
    EXPECT_TRUE(request->has_roadmap());
    EXPECT_GT(request->roadmap().id(), 0);
    EXPECT_FALSE(request->has_user());
    EXPECT_FALSE(request->roadmap().name().empty());

    EXPECT_NO_THROW(m_server->AssignRoadmap(m_server_context.get(), request.get(), response.get()));

    request->set_allocated_user(requesting_user.release());
    EXPECT_TRUE(request->has_user());
    EXPECT_FALSE(request->user().token().empty());
    EXPECT_FALSE(request->user().device().empty());
    EXPECT_NO_THROW(m_server->AssignRoadmap(m_server_context.get(), request.get(), response.get()));
}

TEST_F(test_server, GetRoadmaps)
{
    auto const request{std::make_unique<flashback::GetRoadmapsRequest>()};
    auto const response{std::make_unique<flashback::GetRoadmapsResponse>()};
    auto requesting_user{std::make_unique<flashback::User>(*m_user)};
    auto const database_retrieved_user{std::make_unique<flashback::User>(*m_user)};
    auto const roadmap{std::make_unique<flashback::Roadmap>()};

    EXPECT_CALL(*m_mock_database, get_user(testing::A<std::string_view>(), testing::A<std::string_view>())).Times(2).WillOnce(
        testing::Return(std::make_unique<flashback::User>(*database_retrieved_user))).WillOnce(
        testing::Return(std::make_unique<flashback::User>(*database_retrieved_user)));
    EXPECT_CALL(*m_mock_database, get_roadmaps(testing::A<uint64_t>())).Times(1).WillOnce(testing::Return(std::vector<flashback::Roadmap>{}));

    EXPECT_FALSE(request->has_user());
    EXPECT_NO_THROW(m_server->GetRoadmaps(m_server_context.get(), request.get(), response.get()));

    roadmap->set_id(1);
    roadmap->set_name("Overtime Working Specialist");
    request->set_allocated_user(requesting_user.release());
    EXPECT_TRUE(request->has_user());
    EXPECT_FALSE(request->user().token().empty());
    EXPECT_FALSE(request->user().device().empty());
    EXPECT_NO_THROW(m_server->GetRoadmaps(m_server_context.get(), request.get(), response.get()));
}

TEST_F(test_server, RenameRoadmap)
{
    auto request{std::make_unique<flashback::RenameRoadmapRequest>()};
    auto response{std::make_unique<flashback::RenameRoadmapResponse>()};
    auto requesting_user{std::make_unique<flashback::User>(*m_user)};
    auto database_retrieved_user{std::make_unique<flashback::User>(*m_user)};
    auto roadmap{std::make_unique<flashback::Roadmap>()};

    EXPECT_CALL(*m_mock_database, get_user(testing::A<std::string_view>(), testing::A<std::string_view>())).Times(1).WillOnce(
        testing::Return(std::make_unique<flashback::User>(*database_retrieved_user)));
    EXPECT_CALL(*m_mock_database, rename_roadmap(testing::A<uint64_t>(), testing::A<std::string_view>())).Times(1);

    EXPECT_FALSE(request->has_roadmap());
    EXPECT_FALSE(request->has_user());
    EXPECT_NO_THROW(m_server->RenameRoadmap(m_server_context.get(), request.get(), response.get()));

    roadmap->set_id(1);
    roadmap->set_name("Overtime Working Specialist");
    request->set_allocated_roadmap(roadmap.release());
    EXPECT_TRUE(request->has_roadmap());
    EXPECT_GT(request->roadmap().id(), 0);
    EXPECT_FALSE(request->has_user());
    EXPECT_FALSE(request->roadmap().name().empty());

    EXPECT_NO_THROW(m_server->RenameRoadmap(m_server_context.get(), request.get(), response.get()));

    request->set_allocated_user(requesting_user.release());
    EXPECT_TRUE(request->has_user());
    EXPECT_FALSE(request->user().token().empty());
    EXPECT_FALSE(request->user().device().empty());
    EXPECT_NO_THROW(m_server->RenameRoadmap(m_server_context.get(), request.get(), response.get()));
}

TEST_F(test_server, RemoveRoadmap)
{
    auto request{std::make_unique<flashback::RemoveRoadmapRequest>()};
    auto response{std::make_unique<flashback::RemoveRoadmapResponse>()};
    auto requesting_user{std::make_unique<flashback::User>(*m_user)};
    auto database_retrieved_user{std::make_unique<flashback::User>(*m_user)};
    auto roadmap{std::make_unique<flashback::Roadmap>()};

    EXPECT_CALL(*m_mock_database, get_user(testing::A<std::string_view>(), testing::A<std::string_view>())).Times(1).WillOnce(
        testing::Return(std::make_unique<flashback::User>(*database_retrieved_user)));
    EXPECT_CALL(*m_mock_database, remove_roadmap(testing::A<uint64_t>())).Times(1);

    EXPECT_FALSE(request->has_roadmap());
    EXPECT_FALSE(request->has_user());
    EXPECT_NO_THROW(m_server->RemoveRoadmap(m_server_context.get(), request.get(), response.get()));

    roadmap->set_id(1);
    roadmap->set_name("Overtime Working Specialist");
    request->set_allocated_roadmap(roadmap.release());
    EXPECT_TRUE(request->has_roadmap());
    EXPECT_GT(request->roadmap().id(), 0);
    EXPECT_FALSE(request->has_user());
    EXPECT_FALSE(request->roadmap().name().empty());

    EXPECT_NO_THROW(m_server->RemoveRoadmap(m_server_context.get(), request.get(), response.get()));

    request->set_allocated_user(requesting_user.release());
    EXPECT_TRUE(request->has_user());
    EXPECT_FALSE(request->user().token().empty());
    EXPECT_FALSE(request->user().device().empty());
    EXPECT_NO_THROW(m_server->RemoveRoadmap(m_server_context.get(), request.get(), response.get()));
}

TEST_F(test_server, SearchRoadmaps)
{
    std::unique_ptr<flashback::User> database_retrieved_user{nullptr};
    EXPECT_CALL(*m_mock_database, get_user(testing::A<std::string_view>(), testing::A<std::string_view>())).Times(0);
    EXPECT_CALL(*m_mock_database, search_roadmaps(testing::A<std::string_view>())).Times(0);

    auto search_request{std::make_unique<flashback::SearchRoadmapsRequest>()};
    auto search_response{std::make_unique<flashback::SearchRoadmapsResponse>()};
    EXPECT_FALSE(search_request->has_user());
    EXPECT_NO_THROW(m_server->SearchRoadmaps(m_server_context.get(), search_request.get(), search_response.get()));
    EXPECT_THAT(search_response->roadmap(), testing::SizeIs(0)) << "User is not set so the request will be declined";

    database_retrieved_user = std::make_unique<flashback::User>(*m_user);
    EXPECT_CALL(*m_mock_database, get_user(testing::A<std::string_view>(), testing::A<std::string_view>())).Times(1).WillOnce(
        testing::Return(std::make_unique<flashback::User>(*database_retrieved_user)));
    EXPECT_CALL(*m_mock_database, search_roadmaps(testing::A<std::string_view>())).Times(1).WillOnce(testing::Return(std::vector<flashback::Roadmap>{}));

    auto roadmap{std::make_unique<flashback::Roadmap>()};
    roadmap->set_id(1);
    roadmap->set_name("Overtime Working Specialist");
    search_request->set_allocated_user(std::make_unique<flashback::User>(*m_user).release());
    EXPECT_TRUE(search_request->has_user());
    EXPECT_FALSE(search_request->user().token().empty());
    EXPECT_FALSE(search_request->user().device().empty());
    EXPECT_NO_THROW(m_server->SearchRoadmaps(m_server_context.get(), search_request.get(), search_response.get()));

    database_retrieved_user = std::make_unique<flashback::User>(*m_user);
    EXPECT_CALL(*m_mock_database, get_user(testing::A<std::string_view>(), testing::A<std::string_view>())).Times(1).WillOnce(
        testing::Return(std::make_unique<flashback::User>(*database_retrieved_user)));
    EXPECT_CALL(*m_mock_database, create_roadmap(testing::A<std::string_view>())).Times(1).WillOnce(testing::Return(roadmap->id()));

    grpc::Status status{};
    auto create_request{std::make_unique<flashback::CreateRoadmapRequest>()};
    auto create_response{std::make_unique<flashback::CreateRoadmapResponse>()};
    create_request->set_allocated_user(std::make_unique<flashback::User>(*m_user).release());
    EXPECT_TRUE(create_request->has_user());
    EXPECT_FALSE(create_request->user().token().empty());
    EXPECT_FALSE(create_request->user().device().empty());
    EXPECT_NO_THROW(status = m_server->CreateRoadmap(m_server_context.get(), create_request.get(), create_response.get()));
    EXPECT_TRUE(create_response->has_roadmap()) << "User is set and session is valid, therefore the request should be responded";
    EXPECT_EQ(create_response->roadmap().id(), roadmap->id());

    database_retrieved_user = std::make_unique<flashback::User>(*m_user);
    EXPECT_CALL(*m_mock_database, get_user(testing::A<std::string_view>(), testing::A<std::string_view>())).Times(1).WillOnce(
        testing::Return(std::make_unique<flashback::User>(*database_retrieved_user)));
    EXPECT_CALL(*m_mock_database, search_roadmaps(testing::A<std::string_view>())).Times(1).WillOnce(testing::Return(std::vector<flashback::Roadmap>{}));

    search_request->set_allocated_user(std::make_unique<flashback::User>(*m_user).release());
    EXPECT_TRUE(search_request->has_user());
    EXPECT_FALSE(search_request->user().token().empty());
    EXPECT_FALSE(search_request->user().device().empty());
    EXPECT_NO_THROW(m_server->SearchRoadmaps(m_server_context.get(), search_request.get(), search_response.get()));
}

TEST_F(test_server, CreateSubject)
{
    std::string const subject_name{"C++"};
    grpc::Status status;
    flashback::CreateSubjectRequest request;
    request.set_name(subject_name);
    flashback::CreateSubjectResponse response;
    flashback::Subject returning_subject{};
    returning_subject.set_name(subject_name);
    returning_subject.set_id(1);

    auto const returning_user{std::make_unique<flashback::User>(*m_user)};
    EXPECT_CALL(*m_mock_database, get_user(testing::A<std::string_view>(), testing::A<std::string_view>())).Times(1).WillOnce(
        testing::Return(std::make_unique<flashback::User>(*returning_user)));
    EXPECT_CALL(*m_mock_database, create_subject(testing::A<std::string>())).Times(1).WillOnce(testing::Return(returning_subject));
    EXPECT_NO_THROW(status = m_server->CreateSubject(m_server_context.get(), &request, &response));
    EXPECT_TRUE(status.ok());
    EXPECT_TRUE(response.success());
    EXPECT_EQ(response.code(), 0);
}
